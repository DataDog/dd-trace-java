import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.vafer.jdependency.Clazz
import org.vafer.jdependency.Clazzpath
import org.vafer.jdependency.ClazzpathUnit

import java.util.concurrent.atomic.AtomicBoolean

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath group: 'org.vafer', name: 'jdependency', version: '2.6.0'
  }
}

plugins {
  id "com.github.johnrengelman.shadow"
}

description = 'dd-java-agent'

apply from: "$rootDir/gradle/java.gradle"
apply from: "$rootDir/gradle/publish.gradle"

configurations {
  shadowInclude
  sharedShadowInclude
}

/*
 * 4 shadow jars are created
 * - The main "dd-java-agent" jar that also has the bootstrap project
 * - 2 jars based on projects (jmxfetch, agent tooling)
 * - 1 based on the shared dependencies
 * This general config is shared by all of them
 */

ext.generalShadowJarConfig = {
  mergeServiceFiles()

  exclude '**/module-info.class'

  // Prevents conflict with other SLF4J instances. Important for premain.
  relocate 'org.slf4j', 'datadog.slf4j'
  // rewrite dependencies calling Logger.getLogger
  relocate 'java.util.logging.Logger', 'datadog.trace.bootstrap.PatchLogger'

  if (!project.hasProperty("disableShadowRelocate") || !disableShadowRelocate) {
    // shadow OT impl to prevent casts to implementation
    relocate 'datadog.trace.common', 'datadog.trace.agent.common'
    relocate 'datadog.trace.core', 'datadog.trace.agent.core'
    relocate 'datadog.opentracing', 'datadog.trace.agent.ot'
  }
}

def includeShadowJar(shadowJarTask, jarname, Closure customizeZipProcessing = null) {
  def opentracingFound = new AtomicBoolean()
  project.processResources {
    doFirst {
      eachFile {
        // We seem unlikely to use this name somewhere else.
        if (it.path.contains("opentracing") && it.name.contains("Format\$Builtin")) {
          opentracingFound.set(true)
        }
      }
    }
    doLast {
      if (opentracingFound.get()) {
        throw new GradleException("OpenTracing direct dependency found!")
      }
    }

    from(zipTree(shadowJarTask.archiveFile)) {
      into jarname
      rename '(^.*)\\.class$', '$1.classdata'
      // Rename LICENSE file since it clashes with license dir on non-case sensitive FSs (i.e. Mac)
      rename '^LICENSE$', 'LICENSE.renamed'
      if (customizeZipProcessing) {
        customizeZipProcessing.delegate = it
        customizeZipProcessing.call(it)
      }
    }
  }

  project.processResources.dependsOn shadowJarTask
}

// these include the shared dependencies of the subprojects' shadowJars,
// which are not included in those shadowJars themselves
task sharedShadowJar(type: ShadowJar) {
  configure generalShadowJarConfig
  configurations = [project.configurations.sharedShadowInclude]
  archiveClassifier = 'shared'

  project.processResources.dependsOn it
}
// used to keep track of the shared classes that are actually used by the
// subprojects' shadowJars. The scanning is done in scanUsedClassesFor* tasks
def sharedClassesUsage = [
  clazzpath: new Clazzpath(),

  // Units for subprojects' shadowJars. Classes in these units will be deemed used
  clazzpathUnits: [],

  // the tasks of the subprojects' shadowJars.
  // configureSharedShadowJar (and transitively, the shadowJar) tasks will depend on them
  tasks: []]
def includeSubprojShadowJar = { String projName, String jarname ->
  evaluationDependsOn projName
  def proj = project(projName)
  def shadowJarTask = proj.tasks['shadowJar']

  shadowJarTask.configure generalShadowJarConfig

  def finalJarTask = proj.tasks.findByName('minShadowJar') ?
    proj.tasks['minShadowJar'] : shadowJarTask

  includeShadowJar finalJarTask, jarname

  // register class uses for shared shadow jar minimization
  project.tasks.sharedShadowJar.inputs.file finalJarTask.archiveFile
  def scanTask = project.tasks.create("scanUsedClassesFor${jarname.capitalize()}") {
    inputs.file(finalJarTask.archiveFile)

    doFirst {
      sharedClassesUsage.clazzpathUnits <<
        sharedClassesUsage.clazzpath.addClazzpathUnit(finalJarTask.archiveFile.get().getAsFile())
    }

    dependsOn finalJarTask
  }
  sharedClassesUsage.tasks << scanTask
}

includeSubprojShadowJar ':dd-java-agent:instrumentation', 'inst'
includeSubprojShadowJar ':dd-java-agent:agent-jmxfetch', 'metrics'
includeSubprojShadowJar ':dd-java-agent:agent-profiling', 'profiling'

task configureSharedShadowJar {
  // late configuration of shared shadow jar, depending on the contents
  // of the subprojects' shadow jars
  doFirst {
    def allDeps = tasks.sharedShadowJar.configurations.collectMany {
      it.resolve()
    } as Set
    allDeps.each {
      sharedClassesUsage.clazzpath.addClazzpathUnit(it)
    }

    Set<Clazz> unused = sharedClassesUsage.clazzpath.clazzes
    sharedClassesUsage.clazzpathUnits.each { ClazzpathUnit subprojShadowJarUnit ->
      unused.removeAll(subprojShadowJarUnit.clazzes)
      unused.removeAll(subprojShadowJarUnit.transitiveDependencies)
    }

    def manualInclusions = [
      // https://github.com/jnr/jffi/blob/96a2e8ae0c11eb86d9c718ad0d0421e6360f1a8b/src/main/java/com/kenai/jffi/internal/StubLoader.java#L51
      ~'\\Acom/kenai/jffi/Version\\.class\\z',
      // https://github.com/jnr/jffi/blob/39cfdaff1b7882823dd21f17a11ca68fbf974a92/src/main/java/com/kenai/jffi/Init.java#L51
      ~'\\Acom/kenai/jffi/internal/StubLoader\\.class\\z',
      // https://github.com/jnr/jnr-ffi/blob/a6271ada96075823b6e4417698cdae8d041e8d6b/src/main/java/jnr/ffi/provider/FFIProvider.java#L68
      ~'\\Ajnr/ffi/provider/jffi/Provider\\.class\\z',
      // https://github.com/jnr/jnr-ffi/blob/a6271ada96075823b6e4417698cdae8d041e8d6b/src/main/java/jnr/ffi/provider/jffi/NativeRuntime.java#L95
      ~'\\Ajnr/ffi/provider/jffi/platform/.+/TypeAliases\\.class\\z',
      // see ConstantResolver / ConstantSet
      ~'\\Ajnr/constants/',
    ]

    includeShadowJar(sharedShadowJar, 'shared') {
      exclude unused.collect { clazz ->
        "${clazz.toString().replace('.', '/')}.class"
      }.findAll { entryName ->
        !manualInclusions.any { entryName =~ it }
      }
    }
  }

  dependsOn sharedClassesUsage.tasks
  sharedShadowJar.dependsOn it
}


shadowJar generalShadowJarConfig >> {
  configurations = [project.configurations.shadowInclude]

  archiveClassifier = ''
  includeEmptyDirs = false

  manifest {
    attributes(
      "Main-Class": "datadog.trace.bootstrap.AgentBootstrap",
      "Agent-Class": "datadog.trace.bootstrap.AgentBootstrap",
      "Premain-Class": "datadog.trace.bootstrap.AgentBootstrap",
      "Can-Redefine-Classes": true,
      "Can-Retransform-Classes": true,
      )
  }
}

// We don't want bundled dependencies to show up in the pom.
tasks.withType(GenerateMavenPom).configureEach { task ->
  doFirst {
    task.pom.withXml { XmlProvider provider ->
      Node dependencies = provider.asNode().dependencies[0]
      dependencies.children().clear()
    }
  }
}

dependencies {
  testCompile(project(':dd-java-agent:agent-bootstrap')) {
    exclude group: 'com.datadoghq', module: 'agent-logging'
  }
  testCompile project(':dd-trace-api')
  testCompile project(':dd-trace-core')
  testCompile project(':utils:test-utils')

  testCompile deps.testLogging
  testCompile deps.guava
  testCompile group: 'io.opentracing', name: 'opentracing-util', version: '0.31.0'

  // Includes for the top level shadow jar
  shadowInclude project(path: ':dd-java-agent:agent-bootstrap')

  // Includes for the shared internal shadow jar
  sharedShadowInclude deps.shared
}

tasks.withType(Test).configureEach {
  jvmArgs "-Ddd.service.name=java-agent-tests"
  jvmArgs "-Ddd.writer.type=LoggingWriter"
  // Multi-threaded logging seems to be causing deadlocks with Gradle's log capture.
  //  jvmArgs "-Ddatadog.slf4j.simpleLogger.defaultLogLevel=debug"
  //  jvmArgs "-Dorg.slf4j.simpleLogger.defaultLogLevel=debug"

  doFirst {
    // Defining here to allow jacoco to be first on the command line.
    jvmArgs "-javaagent:${shadowJar.archivePath}"
  }

  testLogging {
    events "started"
  }

  if (project.hasProperty("disableShadowRelocate") && disableShadowRelocate) {
    exclude 'datadog/trace/agent/integration/classloading/ShadowPackageRenamingTest.class'
  }

  dependsOn shadowJar
}

task('checkAgentJarSize') {
  doLast {
    // Arbitrary limit to prevent unintentional increases to the agent jar size
    // Raise or lower as required
    assert shadowJar.archiveFile.get().getAsFile().length() < 14 * 1024 * 1024
  }

  dependsOn shadowJar
}

check.dependsOn 'checkAgentJarSize'
