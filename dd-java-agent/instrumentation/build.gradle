import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
  id 'com.gradleup.shadow'
}
apply from: "$rootDir/gradle/java.gradle"


tasks.register("latestDepTest", Test)

Project parent_project = project
subprojects { Project subProj ->
  apply plugin: 'instrument'
  apply plugin: 'muzzle'

  configurations {
    instrumentPluginClasspath {
      visible = false
      canBeConsumed = false
      canBeResolved = true
    }
  }

  instrument.plugins = [
    'datadog.trace.agent.tooling.muzzle.MuzzleGradlePlugin',
    'datadog.trace.agent.tooling.bytebuddy.NewTaskForGradlePlugin',
    'datadog.trace.agent.tooling.bytebuddy.reqctx.RewriteRequestContextAdvicePlugin',
  ]

  subProj.tasks.withType(Javadoc).configureEach { enabled = false }

  subProj.afterEvaluate {
    if (!plugins.hasPlugin("java")) {
      return
    }
    String jdkCompile = null
    if (project.hasProperty('minJavaVersionForTests') && project.getProperty('minJavaVersionForTests') != JavaVersion.VERSION_1_8) {
      def version = JavaVersion.toVersion(project.getProperty('minJavaVersionForTests'))
      def name = "java$version.majorVersion"
      jdkCompile = "main_${name}Implementation"
    }
    configurations.muzzleBootstrap {
      exclude group: 'org.snakeyaml', module: 'snakeyaml-engine' // we vendor this in the agent jar
    }
    dependencies {
      // Apply common dependencies for instrumentation.
      implementation project(':dd-trace-api')
      implementation project(':dd-java-agent:agent-tooling')
      implementation libs.bytebuddy
      if (jdkCompile) {
        "$jdkCompile" project(':dd-trace-api')
        "$jdkCompile" project(':dd-java-agent:agent-tooling')
        "$jdkCompile" libs.bytebuddy
      }

      annotationProcessor project(':dd-java-agent:instrumentation-annotation-processor')
      annotationProcessor libs.autoservice.processor
      compileOnly libs.autoservice.annotation

      // Include instrumentations instrumenting core JDK classes to ensure interoperability with other instrumentation
      testImplementation project(':dd-java-agent:instrumentation:java:java-concurrent:java-concurrent-1.8')
      // FIXME: we should enable this, but currently this fails tests for google http client
      //testImplementation project(':dd-java-agent:instrumentation:http-url-connection')
      testImplementation project(':dd-java-agent:instrumentation:classloading')

      testImplementation project(':dd-java-agent:instrumentation-testing')
      testAnnotationProcessor libs.autoservice.processor
      testCompileOnly libs.autoservice.annotation

      instrumentPluginClasspath project(path: ':dd-java-agent:agent-tooling', configuration: 'instrumentPluginClasspath')
    }

    subProj.tasks.withType(Test).configureEach { subTask ->
      if (subTask.name in ['latestDepTest', 'latestDepForkedTest']) {
        subTask.jvmArgs '-Dtest.dd.latestDepTest=true'
      }
    }
  }

  def path = subProj.getPath()
  subProj.plugins.withId("java") {
    if (!path.equals(':dd-java-agent:instrumentation:vertx:vertx-redis-client-3.9:stubs')) {
      // don't include the redis RequestImpl stub
      parent_project.dependencies {
        implementation project(path)
      }
    }
  }
}

dependencies {
  implementation(project(':dd-java-agent:agent-tooling')) {
    exclude module: ':dd-java-agent:agent-bootstrap'
  }
  implementation project(':dd-java-agent:agent-builder')
}

if (project.gradle.startParameter.taskNames.any { it.endsWith("generateMuzzleReport") }) {
  apply plugin: 'muzzle'
  tasks.register('muzzleInstrumentationReport') {
    dependsOn(subprojects.collect { p -> p.tasks.matching { it.name == "generateMuzzleReport" } })
    finalizedBy(tasks.named('mergeMuzzleReports'))
  }
}

tasks.named('shadowJar', ShadowJar) {
  duplicatesStrategy = DuplicatesStrategy.FAIL
  dependencies {
    // the tracer is now in a separate shadow jar
    exclude(project(":dd-trace-core"))
    exclude(dependency('com.datadoghq:sketches-java'))
    exclude(dependency('com.google.re2j:re2j'))
  }
  dependencies deps.excludeShared
}

// temporary config to add slf4j-simple so we get logging from instrumenters while indexing
project.configurations.register('slf4j-simple') {
  it.dependencies.add(project.dependencyFactory.create("org.slf4j:slf4j-simple:${libs.versions.slf4j.get()}"))
}

TaskProvider<JavaExec> registerIndexTask(String indexTaskName, String indexer, String description ) {
  def indexTask = tasks.register(indexTaskName, JavaExec) {
    def destinationDir = project.layout.buildDirectory.dir("generated/${it.name}")

    it.group = LifecycleBasePlugin.BUILD_GROUP
    it.description = description
    it.mainClass = indexer
    it.classpath = objects.fileCollection().tap {
      it.from(project.configurations.named("runtimeClasspath"))
      it.from(project.configurations.named('slf4j-simple'))
    }
    it.inputs.files(it.classpath)
    it.outputs.dir(destinationDir)
    it.argumentProviders.add(new CommandLineArgumentProvider() {
        @Override
        Iterable<String> asArguments() {
          return destinationDir.map { [it.asFile.path] }.get()
        }
      })
  }
  sourceSets.main.resources.srcDir(indexTask)
  return indexTask
}

registerIndexTask(
  'generateInstrumenterIndex',
  'datadog.trace.agent.tooling.InstrumenterIndex$IndexGenerator',
  'Generate instrumenter.index'
  )

registerIndexTask(
  'generateKnownTypesIndex',
  'datadog.trace.agent.tooling.KnownTypesIndex$IndexGenerator',
  'Generate known-types.index'
  )
