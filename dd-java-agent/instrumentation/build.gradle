import static org.gradle.api.plugins.JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME
import static org.gradle.api.tasks.SourceSet.MAIN_SOURCE_SET_NAME

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
  id 'com.gradleup.shadow'
  id("dd-trace-java.instrumentation-naming")
}
apply from: "$rootDir/gradle/java.gradle"


tasks.register("latestDepTest", Test)

Project parent_project = project
subprojects { Project subProj ->
  subProj.pluginManager.withPlugin("dd-trace-java.instrument") {
    subProj.extensions.configure(InstrumentExtension) {
      it.plugins.addAll(
        'datadog.trace.agent.tooling.muzzle.MuzzleGradlePlugin',
        'datadog.trace.agent.tooling.bytebuddy.NewTaskForGradlePlugin',
        'datadog.trace.agent.tooling.bytebuddy.reqctx.RewriteRequestContextAdvicePlugin',
        )
    }

    subProj.configurations.named('instrumentPluginClasspath') {
      it.visible = false
      it.canBeConsumed = false
      it.canBeResolved = true

      it.dependencies.add(subProj.dependencies.project(
          path: ':dd-java-agent:agent-tooling',
          configuration: 'instrumentPluginClasspath'
      ))
    }
  }

  subProj.pluginManager.withPlugin("java") {
    subProj.pluginManager.withPlugin("dd-trace-java.muzzle") {
      subProj.configurations.matching { it.name == 'muzzleBootstrap' }.configureEach {
        exclude group: 'org.snakeyaml', module: 'snakeyaml-engine' // we vendor this in the agent jar
      }
    }

    subProj.tasks.withType(Javadoc).configureEach { enabled = false }

    // Configures base dependencies for additional sourceSet
    subProj.configurations
      .matching { it.name.matches("${MAIN_SOURCE_SET_NAME}_java\\d+${IMPLEMENTATION_CONFIGURATION_NAME.capitalize()}") }
      .configureEach {
        it.dependencies.add(subProj.dependencyFactory.create(project(':dd-trace-api')))
        it.dependencies.add(subProj.dependencyFactory.create(project(':dd-java-agent:agent-tooling')))
        it.dependencies.addLater(libs.bytebuddy)
      }

    dependencies {
      // Main
      annotationProcessor project(':dd-java-agent:instrumentation-annotation-processor')
      annotationProcessor libs.autoservice.processor
      compileOnly libs.autoservice.annotation

      // Apply common dependencies for instrumentation.
      implementation project(':dd-trace-api')
      implementation project(':dd-java-agent:agent-tooling')
      implementation libs.bytebuddy

      // Tests
      testAnnotationProcessor libs.autoservice.processor
      testCompileOnly libs.autoservice.annotation

      // Include instrumentations instrumenting core JDK classes to ensure interoperability with other instrumentation
      testImplementation project(':dd-java-agent:instrumentation:java:java-concurrent:java-concurrent-1.8')
      testImplementation project(':dd-java-agent:instrumentation:java:java-lang:java-lang-classloading-1.8')

      testImplementation project(':dd-java-agent:instrumentation-testing')
    }

    subProj.tasks.withType(Test).configureEach { subTask ->
      if (subTask.name in ['latestDepTest', 'latestDepForkedTest']) {
        subTask.jvmArgs '-Dtest.dd.latestDepTest=true'
      }
    }

    if (subProj.path != ':dd-java-agent:instrumentation:vertx:vertx-redis-client:vertx-redis-client-stubs') {
      // don't include the redis RequestImpl stubs
      parent_project.dependencies {
        addProvider("implementation", providers.provider { project(subProj.path) })
      }
    }
  }

  subProj.apply plugin: 'dd-trace-java.instrument'
  subProj.apply plugin: 'dd-trace-java.muzzle'
}

dependencies {
  implementation(project(':dd-java-agent:agent-tooling')) {
    exclude module: ':dd-java-agent:agent-bootstrap'
  }
  implementation project(':dd-java-agent:agent-builder')
}

if (project.gradle.startParameter.taskNames.any { it.endsWith("generateMuzzleReport") }) {
  apply plugin: 'dd-trace-java.muzzle'
  tasks.register('muzzleInstrumentationReport') {
    dependsOn(subprojects.collect { p ->
      p.tasks.matching {
        it.name == "generateMuzzleReport"
      }
    })
    finalizedBy(tasks.named('mergeMuzzleReports'))
  }
}

tasks.named('shadowJar', ShadowJar) {
  duplicatesStrategy = DuplicatesStrategy.FAIL
  dependencies {
    // the tracer is now in a separate shadow jar
    exclude(project(":dd-trace-core"))
    exclude(dependency('com.datadoghq:sketches-java'))
    exclude(dependency('com.google.re2j:re2j'))
  }
  dependencies deps.excludeShared
}

// temporary config to add slf4j-simple so we get logging from instrumenters while indexing
project.configurations.register('slf4j-simple') {
  it.dependencies.add(project.dependencyFactory.create("org.slf4j:slf4j-simple:${libs.versions.slf4j.get()}"))
}

TaskProvider<JavaExec> registerIndexTask(String indexTaskName, String indexer, String description ) {
  def indexTask = tasks.register(indexTaskName, JavaExec) {
    def destinationDir = project.layout.buildDirectory.dir("generated/${it.name}")

    it.group = LifecycleBasePlugin.BUILD_GROUP
    it.description = description
    it.mainClass = indexer
    it.classpath = objects.fileCollection().tap {
      it.from(project.configurations.named("runtimeClasspath"))
      it.from(project.configurations.named('slf4j-simple'))
    }
    it.inputs.files(it.classpath)
    it.outputs.dir(destinationDir)
    it.argumentProviders.add(new CommandLineArgumentProvider() {
        @Override
        Iterable<String> asArguments() {
          return destinationDir.map { [it.asFile.path] }.get()
        }
      })
  }
  sourceSets.main.resources.srcDir(indexTask)
  return indexTask
}

instrumentationNaming {
  exclusions = ["org-json-20230227"] // org-json does not use semver
  suffixes = ["-common", "-stubs", "-iast"]
}

registerIndexTask(
  'generateInstrumenterIndex',
  'datadog.trace.agent.tooling.InstrumenterIndex$IndexGenerator',
  'Generate instrumenter.index'
  )

registerIndexTask(
  'generateKnownTypesIndex',
  'datadog.trace.agent.tooling.KnownTypesIndex$IndexGenerator',
  'Generate known-types.index'
  )
