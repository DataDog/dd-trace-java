package datadog.opentelemetry.tooling;

import datadog.opentelemetry.tooling.OtelMuzzleRefBuilder.ClassRef;
import datadog.trace.agent.tooling.InstrumenterModule;
import datadog.trace.agent.tooling.muzzle.Reference;
import datadog.trace.agent.tooling.muzzle.ReferenceProvider;
import datadog.trace.api.InstrumenterConfig;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.bytebuddy.pool.TypePool;

/**
 * Replaces OpenTelemetry's {@code InstrumentationModule} when mapping extensions.
 *
 * <p>Original instrumentation names and aliases are prefixed with {@literal "otel."}.
 */
public abstract class OtelInstrumenterModule extends InstrumenterModule.Tracing {

  public OtelInstrumenterModule(String instrumentationName, String... additionalNames) {
    super(namespace(instrumentationName), namespace(additionalNames));
  }

  @Override
  protected boolean defaultEnabled() {
    return InstrumenterConfig.get().isTraceOtelEnabled() && super.defaultEnabled();
  }

  private static String namespace(String name) {
    return "otel." + name;
  }

  private static String[] namespace(String[] names) {
    String[] namespaced = new String[names.length];
    for (int i = 0; i < names.length; i++) {
      namespaced[i] = namespace(names[i]);
    }
    return namespaced;
  }

  private volatile String[] helperClassNames;

  @Override
  public String[] helperClassNames() {
    if (null == helperClassNames) {
      helperClassNames = buildHelperClassNames();
    }
    return helperClassNames;
  }

  private String[] buildHelperClassNames() {
    List<String> helperClassNames;
    List<String> additionalClassNames = getAdditionalHelperClassNames();
    if (additionalClassNames.isEmpty()) {
      // no additional names, just use those captured at build time
      helperClassNames = getMuzzleHelperClassNames();
    } else {
      // combine names captured at build time with additional names
      helperClassNames = new ArrayList<>(getMuzzleHelperClassNames());
      helperClassNames.addAll(additionalClassNames);
    }
    if (helperClassNames.isEmpty()) {
      return NO_HELPERS;
    } else {
      return helperClassNames.toArray(new String[0]);
    }
  }

  /** This method is generated by OpenTelemetry's muzzle plugin at build time. */
  public List<String> getMuzzleHelperClassNames() {
    return Collections.emptyList();
  }

  /** Extensions override this to supply names not covered by the muzzle plugin. */
  public List<String> getAdditionalHelperClassNames() {
    return Collections.emptyList();
  }

  @Override
  public Map<String, String> contextStore() {
    Map<String, String> virtualFields = new HashMap<>();
    registerMuzzleVirtualFields(
        new VirtualFieldBuilder() {
          @Override
          public VirtualFieldBuilder register(String typeName, String fieldTypeName) {
            virtualFields.put(typeName, fieldTypeName);
            return this;
          }
        });
    return virtualFields;
  }

  /** This method is generated by OpenTelemetry's muzzle plugin at build time. */
  public void registerMuzzleVirtualFields(VirtualFieldBuilder builder) {}

  public interface VirtualFieldBuilder {
    VirtualFieldBuilder register(String typeName, String fieldTypeName);
  }

  @Override
  public ReferenceProvider runtimeMuzzleReferences() {
    return new ReferenceProvider() {
      private volatile Iterable<Reference> muzzleReferences;

      @Override
      @SuppressWarnings({"unchecked", "rawtypes"})
      public Iterable<Reference> buildReferences(TypePool ignored) {
        if (null == muzzleReferences) {
          Map<String, ClassRef> muzzleMap = getMuzzleReferences();
          for (String helper : helperClassNames()) {
            muzzleMap.remove(helper);
          }
          muzzleReferences = (Iterable) muzzleMap.values();
        }
        return muzzleReferences;
      }
    };
  }

  /** This method is generated by OpenTelemetry's muzzle plugin at build time. */
  public Map<String, ClassRef> getMuzzleReferences() {
    return Collections.emptyMap();
  }
}
