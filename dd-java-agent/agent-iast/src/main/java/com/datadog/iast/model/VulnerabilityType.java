package com.datadog.iast.model;

import static datadog.trace.api.iast.VulnerabilityMarks.NOT_MARKED;

import datadog.trace.api.iast.VulnerabilityMarks;
import datadog.trace.api.iast.VulnerabilityTypes;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.zip.CRC32;
import javax.annotation.Nonnull;

public interface VulnerabilityType {
  VulnerabilityType WEAK_CIPHER = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_CIPHER);
  VulnerabilityType WEAK_HASH = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_HASH);
  VulnerabilityType INSECURE_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.INSECURE_COOKIE);
  VulnerabilityType NO_HTTPONLY_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.NO_HTTPONLY_COOKIE);
  VulnerabilityType HSTS_HEADER_MISSING =
      new HeaderVulnerabilityType(VulnerabilityTypes.HSTS_HEADER_MISSING);
  VulnerabilityType XCONTENTTYPE_HEADER_MISSING =
      new HeaderVulnerabilityType(VulnerabilityTypes.XCONTENTTYPE_HEADER_MISSING);
  VulnerabilityType NO_SAMESITE_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.NO_SAMESITE_COOKIE);

  InjectionType SQL_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.SQL_INJECTION, VulnerabilityMarks.SQL_INJECTION_MARK);
  InjectionType COMMAND_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.COMMAND_INJECTION, VulnerabilityMarks.COMMAND_INJECTION_MARK);
  InjectionType PATH_TRAVERSAL =
      new InjectionTypeImpl(
          File.separatorChar,
          VulnerabilityTypes.PATH_TRAVERSAL,
          VulnerabilityMarks.PATH_TRAVERSAL_MARK);
  InjectionType LDAP_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.LDAP_INJECTION, VulnerabilityMarks.LDAP_INJECTION_MARK);
  InjectionType SSRF = new InjectionTypeImpl(VulnerabilityTypes.SSRF, VulnerabilityMarks.SSRF_MARK);
  InjectionType UNVALIDATED_REDIRECT =
      new InjectionTypeImpl(
          VulnerabilityTypes.UNVALIDATED_REDIRECT, VulnerabilityMarks.UNVALIDATED_REDIRECT_MARK);
  VulnerabilityType WEAK_RANDOMNESS = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_RANDOMNESS);

  InjectionType XPATH_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.XPATH_INJECTION, VulnerabilityMarks.XPATH_INJECTION_MARK);

  InjectionType TRUST_BOUNDARY_VIOLATION =
      new InjectionTypeImpl(
          VulnerabilityTypes.TRUST_BOUNDARY_VIOLATION, VulnerabilityMarks.TRUST_BOUNDARY_VIOLATION);

  InjectionType XSS = new InjectionTypeImpl(VulnerabilityTypes.XSS, VulnerabilityMarks.XSS_MARK);

  InjectionType HEADER_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.HEADER_INJECTION, VulnerabilityMarks.HEADER_INJECTION_MARK);

  VulnerabilityType STACKTRACE_LEAK = new VulnerabilityTypeImpl(VulnerabilityTypes.STACKTRACE_LEAK);

  VulnerabilityType VERB_TAMPERING = new VulnerabilityTypeImpl(VulnerabilityTypes.VERB_TAMPERING);

  VulnerabilityType ADMIN_CONSOLE_ACTIVE =
      new VulnerabilityTypeImpl(VulnerabilityTypes.ADMIN_CONSOLE_ACTIVE);

  VulnerabilityType DEFAULT_HTML_ESCAPE_INVALID =
      new VulnerabilityTypeImpl(VulnerabilityTypes.DEFAULT_HTML_ESCAPE_INVALID);

  VulnerabilityType SESSION_TIMEOUT = new VulnerabilityTypeImpl(VulnerabilityTypes.SESSION_TIMEOUT);

  VulnerabilityType DIRECTORY_LISTING_LEAK =
      new VulnerabilityTypeImpl(VulnerabilityTypes.DIRECTORY_LISTING_LEAK);
  VulnerabilityType INSECURE_JSP_LAYOUT =
      new VulnerabilityTypeImpl(VulnerabilityTypes.INSECURE_JSP_LAYOUT);

  VulnerabilityType HARDCODED_SECRET =
      new VulnerabilityTypeImpl(VulnerabilityTypes.HARDCODED_SECRET);

  String name();

  /** A bit flag to ignore tainted ranges for this vulnerability. Set to 0 if none. */
  int mark();

  long calculateHash(@Nonnull final Vulnerability vulnerability);

  interface InjectionType extends VulnerabilityType {
    char evidenceSeparator();
  }

  class VulnerabilityTypeImpl implements VulnerabilityType {

    private final byte type;

    private final int mark;

    public VulnerabilityTypeImpl(final byte type, final int... marks) {
      this.type = type;
      mark = computeMarks(marks);
    }

    @Override
    public String name() {
      return VulnerabilityTypes.toString(type);
    }

    @Override
    public int mark() {
      return mark;
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      final Location location = vulnerability.getLocation();
      if (location != null) {
        crc.update(location.getLine());
        if (location.getPath() != null) {
          update(crc, location.getPath());
        }
        if (location.getLine() <= -1 && location.getMethod() != null) {
          update(crc, location.getMethod());
        }
      }
      return crc.getValue();
    }

    protected void update(final CRC32 crc, final String value) {
      final byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
      crc.update(bytes, 0, bytes.length);
    }

    private static int computeMarks(final int... marks) {
      int result = NOT_MARKED;
      for (final int mark : marks) {
        result |= mark;
      }
      return result;
    }
  }

  class InjectionTypeImpl extends VulnerabilityTypeImpl implements InjectionType {
    private final char evidenceSeparator;

    public InjectionTypeImpl(final byte type, int... marks) {
      this(' ', type, marks);
    }

    public InjectionTypeImpl(final char evidenceSeparator, final byte type, int... marks) {
      super(type, marks);
      this.evidenceSeparator = evidenceSeparator;
    }

    @Override
    public char evidenceSeparator() {
      return evidenceSeparator;
    }
  }

  class HeaderVulnerabilityType extends VulnerabilityTypeImpl {
    public HeaderVulnerabilityType(byte type, int... marks) {
      super(type, marks);
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      String serviceName = vulnerability.getLocation().getServiceName();
      if (serviceName != null) {
        update(crc, serviceName);
      }
      return crc.getValue();
    }
  }

  class CookieVulnerabilityType extends VulnerabilityTypeImpl {
    public CookieVulnerabilityType(byte type, int... marks) {
      super(type, marks);
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      final Evidence evidence = vulnerability.getEvidence();
      if (evidence != null) {
        update(crc, evidence.getValue());
      }
      return crc.getValue();
    }
  }
}
