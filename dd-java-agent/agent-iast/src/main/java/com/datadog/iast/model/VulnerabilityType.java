package com.datadog.iast.model;

import static com.datadog.iast.util.CRCUtils.update;
import static datadog.trace.api.iast.VulnerabilityMarks.COMMAND_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.EMAIL_HTML_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.HEADER_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.LDAP_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.NOT_MARKED;
import static datadog.trace.api.iast.VulnerabilityMarks.PATH_TRAVERSAL_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.REFLECTION_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.SQL_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.SSRF_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.TRUST_BOUNDARY_VIOLATION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.UNTRUSTED_DESERIALIZATION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.UNVALIDATED_REDIRECT_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.XPATH_INJECTION_MARK;
import static datadog.trace.api.iast.VulnerabilityMarks.XSS_MARK;

import datadog.trace.api.iast.SourceTypes;
import datadog.trace.api.iast.VulnerabilityTypes;
import java.io.File;
import java.util.BitSet;
import java.util.function.BiFunction;
import java.util.zip.CRC32;
import javax.annotation.Nonnull;

public interface VulnerabilityType {

  VulnerabilityType WEAK_CIPHER =
      type(VulnerabilityTypes.WEAK_CIPHER).excludedSources(Builder.DB_EXCLUDED).build();
  VulnerabilityType WEAK_HASH =
      type(VulnerabilityTypes.WEAK_HASH).excludedSources(Builder.DB_EXCLUDED).build();
  VulnerabilityType INSECURE_COOKIE =
      type(VulnerabilityTypes.INSECURE_COOKIE)
          .hash(VulnerabilityType::fileAndLineHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType NO_HTTPONLY_COOKIE =
      type(VulnerabilityTypes.NO_HTTPONLY_COOKIE)
          .hash(VulnerabilityType::fileAndLineHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType HSTS_HEADER_MISSING =
      type(VulnerabilityTypes.HSTS_HEADER_MISSING)
          .hash(VulnerabilityType::serviceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType XCONTENTTYPE_HEADER_MISSING =
      type(VulnerabilityTypes.XCONTENTTYPE_HEADER_MISSING)
          .hash(VulnerabilityType::serviceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType NO_SAMESITE_COOKIE =
      type(VulnerabilityTypes.NO_SAMESITE_COOKIE)
          .hash(VulnerabilityType::fileAndLineHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType SQL_INJECTION =
      type(VulnerabilityTypes.SQL_INJECTION).mark(SQL_INJECTION_MARK).build();
  VulnerabilityType COMMAND_INJECTION =
      type(VulnerabilityTypes.COMMAND_INJECTION)
          .mark(COMMAND_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType PATH_TRAVERSAL =
      type(VulnerabilityTypes.PATH_TRAVERSAL)
          .separator(File.separatorChar)
          .mark(PATH_TRAVERSAL_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType LDAP_INJECTION =
      type(VulnerabilityTypes.LDAP_INJECTION)
          .mark(LDAP_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType SSRF =
      type(VulnerabilityTypes.SSRF).mark(SSRF_MARK).excludedSources(Builder.DB_EXCLUDED).build();
  VulnerabilityType UNVALIDATED_REDIRECT =
      type(VulnerabilityTypes.UNVALIDATED_REDIRECT)
          .mark(UNVALIDATED_REDIRECT_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();
  VulnerabilityType WEAK_RANDOMNESS =
      type(VulnerabilityTypes.WEAK_RANDOMNESS).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType XPATH_INJECTION =
      type(VulnerabilityTypes.XPATH_INJECTION)
          .mark(XPATH_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType TRUST_BOUNDARY_VIOLATION =
      type(VulnerabilityTypes.TRUST_BOUNDARY_VIOLATION)
          .mark(TRUST_BOUNDARY_VIOLATION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType XSS = type(VulnerabilityTypes.XSS).mark(XSS_MARK).build();

  VulnerabilityType HEADER_INJECTION =
      type(VulnerabilityTypes.HEADER_INJECTION)
          .mark(HEADER_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType STACKTRACE_LEAK =
      type(VulnerabilityTypes.STACKTRACE_LEAK).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType VERB_TAMPERING =
      type(VulnerabilityTypes.VERB_TAMPERING).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType ADMIN_CONSOLE_ACTIVE =
      type(VulnerabilityTypes.ADMIN_CONSOLE_ACTIVE)
          .deduplicable(false)
          .hash(VulnerabilityType::serviceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType DEFAULT_HTML_ESCAPE_INVALID =
      type(VulnerabilityTypes.DEFAULT_HTML_ESCAPE_INVALID)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType SESSION_TIMEOUT =
      type(VulnerabilityTypes.SESSION_TIMEOUT).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType DIRECTORY_LISTING_LEAK =
      type(VulnerabilityTypes.DIRECTORY_LISTING_LEAK).excludedSources(Builder.DB_EXCLUDED).build();
  VulnerabilityType INSECURE_JSP_LAYOUT =
      type(VulnerabilityTypes.INSECURE_JSP_LAYOUT).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType HARDCODED_SECRET =
      type(VulnerabilityTypes.HARDCODED_SECRET).excludedSources(Builder.DB_EXCLUDED).build();

  VulnerabilityType INSECURE_AUTH_PROTOCOL =
      type(VulnerabilityTypes.INSECURE_AUTH_PROTOCOL)
          .hash(VulnerabilityType::evidenceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType REFLECTION_INJECTION =
      type(VulnerabilityTypes.REFLECTION_INJECTION)
          .mark(REFLECTION_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType SESSION_REWRITING =
      type(VulnerabilityTypes.SESSION_REWRITING)
          .deduplicable(false)
          .hash(VulnerabilityType::serviceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType DEFAULT_APP_DEPLOYED =
      type(VulnerabilityTypes.DEFAULT_APP_DEPLOYED)
          .deduplicable(false)
          .hash(VulnerabilityType::serviceHash)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType UNTRUSTED_DESERIALIZATION =
      type(VulnerabilityTypes.UNTRUSTED_DESERIALIZATION)
          .mark(UNTRUSTED_DESERIALIZATION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  VulnerabilityType EMAIL_HTML_INJECTION =
      type(VulnerabilityTypes.EMAIL_HTML_INJECTION)
          .mark(EMAIL_HTML_INJECTION_MARK)
          .excludedSources(Builder.DB_EXCLUDED)
          .build();

  /* All vulnerability types that have a mark. Should be updated if new vulnerabilityType with mark is added */
  VulnerabilityType[] MARKED_VULNERABILITIES = {
    SQL_INJECTION,
    COMMAND_INJECTION,
    PATH_TRAVERSAL,
    LDAP_INJECTION,
    SSRF,
    UNVALIDATED_REDIRECT,
    XPATH_INJECTION,
    TRUST_BOUNDARY_VIOLATION,
    XSS,
    HEADER_INJECTION,
    REFLECTION_INJECTION,
    UNTRUSTED_DESERIALIZATION,
    EMAIL_HTML_INJECTION
  };

  String name();

  /** A bit flag to ignore tainted ranges for this vulnerability. Set to 0 if none. */
  int mark();

  char separator();

  long calculateHash(@Nonnull final Vulnerability vulnerability);

  /** A flag to indicate if the vulnerability is deduplicable. */
  boolean isDeduplicable();

  byte type();

  BitSet excludedSources();

  static Builder type(final byte type) {
    return new Builder(type);
  }

  class VulnerabilityTypeImpl implements VulnerabilityType {

    private final byte type;

    private final char separator;

    private final int mark;

    private final boolean deduplicable;

    private final BitSet excludedSources;

    private final BiFunction<VulnerabilityType, Vulnerability, Long> hash;

    public VulnerabilityTypeImpl(
        final byte type,
        final char separator,
        final int mark,
        final boolean deduplicable,
        final BitSet excludedSources,
        final BiFunction<VulnerabilityType, Vulnerability, Long> hash) {
      this.type = type;
      this.separator = separator;
      this.mark = mark;
      this.deduplicable = deduplicable;
      this.excludedSources = excludedSources;
      this.hash = hash;
    }

    @Override
    public String name() {
      return VulnerabilityTypes.toString(type);
    }

    @Override
    public int mark() {
      return mark;
    }

    @Override
    public char separator() {
      return separator;
    }

    @Override
    public long calculateHash(@Nonnull Vulnerability vulnerability) {
      return hash.apply(this, vulnerability);
    }

    @Override
    public boolean isDeduplicable() {
      return deduplicable;
    }

    @Override
    public byte type() {
      return type;
    }

    @Override
    public BitSet excludedSources() {
      return excludedSources;
    }

    /** Useful for troubleshooting issues when vulns are serialized without moshi */
    public String getName() {
      return name();
    }
  }

  class Builder {
    private static final BitSet DB_EXCLUDED;

    static {
      DB_EXCLUDED = new BitSet(SourceTypes.STRINGS.length + 1);
      DB_EXCLUDED.set(SourceTypes.SQL_TABLE);
    }

    private final byte type;
    private char separator = ' ';
    private int mark = NOT_MARKED;
    private boolean deduplicable = true;
    private BitSet excludedSources = new BitSet();
    private BiFunction<VulnerabilityType, Vulnerability, Long> hash =
        VulnerabilityType::fileAndLineHash;

    public Builder(byte type) {
      this.type = type;
    }

    public Builder separator(final char separator) {
      this.separator = separator;
      return this;
    }

    public Builder mark(final int mark) {
      this.mark = mark;
      return this;
    }

    public Builder deduplicable(final boolean deduplicable) {
      this.deduplicable = deduplicable;
      return this;
    }

    public Builder excludedSources(final BitSet excludedSources) {
      this.excludedSources = excludedSources;
      return this;
    }

    public Builder hash(final BiFunction<VulnerabilityType, Vulnerability, Long> hash) {
      this.hash = hash;
      return this;
    }

    public VulnerabilityType build() {
      return new VulnerabilityTypeImpl(type, separator, mark, deduplicable, excludedSources, hash);
    }
  }

  static long fileAndLineHash(final VulnerabilityType type, final Vulnerability vulnerability) {
    CRC32 crc = new CRC32();
    update(crc, type.name());
    final Location location = vulnerability.getLocation();
    if (location != null) {
      crc.update(location.getLine());
      if (location.getPath() != null) {
        update(crc, location.getPath());
      }
      if (location.getLine() <= -1 && location.getMethod() != null) {
        update(crc, location.getMethod());
      }
    }
    return crc.getValue();
  }

  static long evidenceHash(final VulnerabilityType type, final Vulnerability vulnerability) {
    CRC32 crc = new CRC32();
    update(crc, type.name());
    final Evidence evidence = vulnerability.getEvidence();
    if (evidence != null) {
      update(crc, evidence.getValue());
    }
    return crc.getValue();
  }

  static long serviceHash(final VulnerabilityType type, final Vulnerability vulnerability) {
    CRC32 crc = new CRC32();
    update(crc, type.name());
    final String serviceName = vulnerability.getLocation().getServiceName();
    if (serviceName != null) {
      update(crc, serviceName);
    }
    return crc.getValue();
  }
}
