package com.datadog.iast.model;

import datadog.trace.api.iast.VulnerabilityTypes;
import java.io.File;
import java.util.zip.CRC32;
import javax.annotation.Nonnull;

public interface VulnerabilityType {
  VulnerabilityType WEAK_CIPHER = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_CIPHER);
  VulnerabilityType WEAK_HASH = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_HASH);
  VulnerabilityType INSECURE_COOKIE = new VulnerabilityTypeImpl(VulnerabilityTypes.INSECURE_COOKIE);
  VulnerabilityType NO_HTTPONLY_COOKIE =
      new VulnerabilityTypeImpl(VulnerabilityTypes.NO_HTTPONLY_COOKIE);
  VulnerabilityType NO_SAMESITE_COOKIE =
      new VulnerabilityTypeImpl(VulnerabilityTypes.NO_SAMESITE_COOKIE);

  InjectionType SQL_INJECTION = new InjectionTypeImpl(VulnerabilityTypes.SQL_INJECTION, ' ');
  InjectionType COMMAND_INJECTION =
      new InjectionTypeImpl(VulnerabilityTypes.COMMAND_INJECTION, ' ');
  InjectionType PATH_TRAVERSAL =
      new InjectionTypeImpl(VulnerabilityTypes.PATH_TRAVERSAL, File.separatorChar);
  InjectionType LDAP_INJECTION = new InjectionTypeImpl(VulnerabilityTypes.LDAP_INJECTION, ' ');
  InjectionType SSRF = new InjectionTypeImpl(VulnerabilityTypes.SSRF, ' ');
  InjectionType UNVALIDATED_REDIRECT =
      new InjectionTypeImpl(VulnerabilityTypes.UNVALIDATED_REDIRECT, ' ');
  VulnerabilityType WEAK_RANDOMNESS = new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_RANDOMNESS);

  String name();

  long calculateHash(@Nonnull final Vulnerability vulnerability);

  interface InjectionType extends VulnerabilityType {
    char evidenceSeparator();
  }

  class VulnerabilityTypeImpl implements VulnerabilityType {

    private final String name;

    public VulnerabilityTypeImpl(@Nonnull final String name) {
      this.name = name;
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      crc.update(name().getBytes());
      final Location location = vulnerability.getLocation();
      if (location != null) {
        crc.update(location.getLine());
        crc.update(location.getPath().getBytes());
        if (location.getLine() <= -1 && location.getMethod() != null) {
          crc.update(location.getMethod().getBytes());
        }
      }
      return crc.getValue();
    }
  }

  class InjectionTypeImpl extends VulnerabilityTypeImpl implements InjectionType {
    private final char evidenceSeparator;

    public InjectionTypeImpl(@Nonnull final String name, final char evidenceSeparator) {
      super(name);
      this.evidenceSeparator = evidenceSeparator;
    }

    @Override
    public char evidenceSeparator() {
      return evidenceSeparator;
    }
  }
}
