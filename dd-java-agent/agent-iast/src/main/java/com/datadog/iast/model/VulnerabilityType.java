package com.datadog.iast.model;

import static datadog.trace.api.iast.VulnerabilityMarks.NOT_MARKED;

import datadog.trace.api.iast.VulnerabilityMarks;
import datadog.trace.api.iast.VulnerabilityTypes;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.zip.CRC32;
import javax.annotation.Nonnull;

public interface VulnerabilityType {
  VulnerabilityType WEAK_CIPHER =
      new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_CIPHER_STRING, NOT_MARKED);
  VulnerabilityType WEAK_HASH =
      new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_HASH_STRING, NOT_MARKED);
  VulnerabilityType INSECURE_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.INSECURE_COOKIE_STRING, NOT_MARKED);
  VulnerabilityType NO_HTTPONLY_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.NO_HTTPONLY_COOKIE_STRING, NOT_MARKED);
  VulnerabilityType HSTS_HEADER_MISSING =
      new HeaderVulnerabilityType(VulnerabilityTypes.HSTS_HEADER_MISSING_STRING, NOT_MARKED);
  VulnerabilityType XCONTENTTYPE_HEADER_MISSING =
      new HeaderVulnerabilityType(
          VulnerabilityTypes.XCONTENTTYPE_HEADER_MISSING_STRING, NOT_MARKED);
  VulnerabilityType NO_SAMESITE_COOKIE =
      new CookieVulnerabilityType(VulnerabilityTypes.NO_SAMESITE_COOKIE_STRING, NOT_MARKED);

  InjectionType SQL_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.SQL_INJECTION_STRING, VulnerabilityMarks.SQL_INJECTION_MARK, ' ');
  InjectionType COMMAND_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.COMMAND_INJECTION_STRING,
          VulnerabilityMarks.COMMAND_INJECTION_MARK,
          ' ');
  InjectionType PATH_TRAVERSAL =
      new InjectionTypeImpl(
          VulnerabilityTypes.PATH_TRAVERSAL_STRING,
          VulnerabilityMarks.PATH_TRAVERSAL_MARK,
          File.separatorChar);
  InjectionType LDAP_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.LDAP_INJECTION_STRING, VulnerabilityMarks.LDAP_INJECTION_MARK, ' ');
  InjectionType SSRF =
      new InjectionTypeImpl(VulnerabilityTypes.SSRF_STRING, VulnerabilityMarks.SSRF_MARK, ' ');
  InjectionType UNVALIDATED_REDIRECT =
      new InjectionTypeImpl(
          VulnerabilityTypes.UNVALIDATED_REDIRECT_STRING,
          VulnerabilityMarks.UNVALIDATED_REDIRECT_MARK,
          ' ');
  VulnerabilityType WEAK_RANDOMNESS =
      new VulnerabilityTypeImpl(VulnerabilityTypes.WEAK_RANDOMNESS_STRING, NOT_MARKED);

  InjectionType XPATH_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.XPATH_INJECTION_STRING, VulnerabilityMarks.XPATH_INJECTION_MARK, ' ');

  InjectionType TRUST_BOUNDARY_VIOLATION =
      new InjectionTypeImpl(
          VulnerabilityTypes.TRUST_BOUNDARY_VIOLATION_STRING,
          VulnerabilityMarks.TRUST_BOUNDARY_VIOLATION,
          ' ');

  InjectionType XSS =
      new InjectionTypeImpl(VulnerabilityTypes.XSS_STRING, VulnerabilityMarks.XSS_MARK, ' ');

  InjectionType HEADER_INJECTION =
      new InjectionTypeImpl(
          VulnerabilityTypes.HEADER_INJECTION_STRING,
          VulnerabilityMarks.HEADER_INJECTION_MARK,
          ' ');

  VulnerabilityType STACKTRACE_LEAK =
      new VulnerabilityTypeImpl(VulnerabilityTypes.STACKTRACE_LEAK_STRING, NOT_MARKED);

  VulnerabilityType VERB_TAMPERING =
      new VulnerabilityTypeImpl(VulnerabilityTypes.VERB_TAMPERING_STRING, NOT_MARKED);

  VulnerabilityType ADMIN_CONSOLE_ACTIVE =
      new VulnerabilityTypeImpl(VulnerabilityTypes.ADMIN_CONSOLE_ACTIVE_STRING, NOT_MARKED);

  VulnerabilityType DEFAULT_HTML_ESCAPE_INVALID =
      new VulnerabilityTypeImpl(VulnerabilityTypes.DEFAULT_HTML_ESCAPE_INVALID_STRING, NOT_MARKED);

  VulnerabilityType SESSION_TIMEOUT =
      new VulnerabilityTypeImpl(VulnerabilityTypes.SESSION_TIMEOUT_STRING, NOT_MARKED);

  VulnerabilityType DIRECTORY_LISTING_LEAK =
      new VulnerabilityTypeImpl(VulnerabilityTypes.DIRECTORY_LISTING_LEAK_STRING, NOT_MARKED);
  VulnerabilityType INSECURE_JSP_LAYOUT =
      new VulnerabilityTypeImpl(VulnerabilityTypes.INSECURE_JSP_LAYOUT_STRING, NOT_MARKED);;

  String name();

  /** A bit flag to ignore tainted ranges for this vulnerability. Set to 0 if none. */
  int mark();

  long calculateHash(@Nonnull final Vulnerability vulnerability);

  interface InjectionType extends VulnerabilityType {
    char evidenceSeparator();
  }

  class VulnerabilityTypeImpl implements VulnerabilityType {

    private final String name;

    private final int mark;

    public VulnerabilityTypeImpl(@Nonnull final String name, final int vulnerabilityMark) {
      this.name = name;
      mark = vulnerabilityMark;
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public int mark() {
      return mark;
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      final Location location = vulnerability.getLocation();
      if (location != null) {
        crc.update(location.getLine());
        if (location.getPath() != null) {
          update(crc, location.getPath());
        }
        if (location.getLine() <= -1 && location.getMethod() != null) {
          update(crc, location.getMethod());
        }
      }
      return crc.getValue();
    }

    protected void update(final CRC32 crc, final String value) {
      final byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
      crc.update(bytes, 0, bytes.length);
    }
  }

  class InjectionTypeImpl extends VulnerabilityTypeImpl implements InjectionType {
    private final char evidenceSeparator;

    public InjectionTypeImpl(
        @Nonnull final String name, final int vulnerabilityMark, final char evidenceSeparator) {
      super(name, vulnerabilityMark);
      this.evidenceSeparator = evidenceSeparator;
    }

    @Override
    public char evidenceSeparator() {
      return evidenceSeparator;
    }
  }

  class HeaderVulnerabilityType extends VulnerabilityTypeImpl {
    public HeaderVulnerabilityType(@Nonnull String name, int vulnerabilityMark) {
      super(name, vulnerabilityMark);
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      String serviceName = vulnerability.getLocation().getServiceName();
      if (serviceName != null) {
        update(crc, serviceName);
      }
      return crc.getValue();
    }
  }

  class CookieVulnerabilityType extends VulnerabilityTypeImpl {
    public CookieVulnerabilityType(@Nonnull String name, int vulnerabilityMark) {
      super(name, vulnerabilityMark);
    }

    @Override
    public long calculateHash(@Nonnull final Vulnerability vulnerability) {
      CRC32 crc = new CRC32();
      update(crc, name());
      final Evidence evidence = vulnerability.getEvidence();
      if (evidence != null) {
        update(crc, evidence.getValue());
      }
      return crc.getValue();
    }
  }
}
