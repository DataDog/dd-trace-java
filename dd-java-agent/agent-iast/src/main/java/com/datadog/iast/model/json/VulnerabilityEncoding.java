package com.datadog.iast.model.json;

import com.datadog.iast.model.VulnerabilityBatch;
import com.squareup.moshi.JsonAdapter;
import com.squareup.moshi.Moshi;
import datadog.trace.api.iast.telemetry.IastMetric;
import datadog.trace.api.iast.telemetry.IastMetricCollector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class VulnerabilityEncoding {

  private static final Logger log = LoggerFactory.getLogger(VulnerabilityEncoding.class);
  private static final int MAX_SPAN_TAG_SIZE = 25000;

  static final Moshi MOSHI =
      new Moshi.Builder().add(new SourceTypeAdapter()).add(new AdapterFactory()).build();

  private static final JsonAdapter<VulnerabilityBatch> BATCH_ADAPTER =
      MOSHI.adapter(VulnerabilityBatch.class);

  private static final JsonAdapter<TruncatedVulnerabilities> TRUNCATED_VULNERABILITIES_ADAPTER =
      MOSHI.adapter(TruncatedVulnerabilities.class);

  public static String toJson(final VulnerabilityBatch value) {
    try {
      String json = BATCH_ADAPTER.toJson(value);
      return json.getBytes().length > MAX_SPAN_TAG_SIZE
          ? getExceededTagSizeJson(new TruncatedVulnerabilities(value.getVulnerabilities()))
          : json;
    } catch (Exception ex) {
      log.debug("Vulnerability serialization error", ex);
      return "{\"vulnerabilities\":[]}";
    }
  }

  static String getExceededTagSizeJson(final TruncatedVulnerabilities truncatedVulnerabilities) {
    IastMetricCollector.add(IastMetric.JSON_TAG_SIZE_EXCEED, 1);
    return TRUNCATED_VULNERABILITIES_ADAPTER.toJson(truncatedVulnerabilities);
  }
}
