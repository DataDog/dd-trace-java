package com.datadog.iast.model.json

import com.datadog.iast.model.Evidence
import com.datadog.iast.model.Location
import com.datadog.iast.model.Range
import com.datadog.iast.model.Source
import com.datadog.iast.model.Vulnerability
import com.datadog.iast.model.VulnerabilityBatch
import com.datadog.iast.model.VulnerabilityType
import datadog.trace.api.config.IastConfig
import datadog.trace.api.iast.SourceTypes
import datadog.trace.api.iast.telemetry.IastMetric
import datadog.trace.api.iast.telemetry.IastMetricCollector
import datadog.trace.bootstrap.instrumentation.api.AgentSpan
import datadog.trace.test.util.DDSpecification
import org.skyscreamer.jsonassert.JSONAssert
import spock.lang.Shared

import java.util.regex.Matcher
import java.util.regex.Pattern

import static datadog.trace.api.iast.VulnerabilityMarks.NOT_MARKED

class VulnerabilityEncodingTest extends DDSpecification {

  @Shared
  final IastMetricCollector defaultCollector = IastMetricCollector.get()

  @Override
  void setup() {
    injectSysConfig(IastConfig.IAST_REDACTION_ENABLED, 'false')
  }

  @Override
  void cleanupSpec() {
    IastMetricCollector.register(defaultCollector)
  }

  void 'null vulnerability'() {
    given:
    final value = new VulnerabilityBatch()
    value.add(null)

    when:
    def result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": []
    }''', result, true)

    when:
    result = VulnerabilityEncoding.getExceededTagSizeJson(new TruncatedVulnerabilities(value.getVulnerabilities()))

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": []
    }''', result, true)
  }

  void 'one vulnerability'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("MD5")
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "MD5"
          },
          "hash":1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ]
    }''', result, true)
  }

  void 'one vulnerability with no spanId'() {
    given:
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(null, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("MD5")
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "MD5"
          },
          "hash":1042880134,
          "location": {
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ]
    }''', result, true)
  }

  void 'one vulnerability with one source'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD", [new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key", "value"), NOT_MARKED)] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "AD"}
            ]
          },
          "hash":1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "origin": "http.request.parameter",
          "name": "key",
          "value": "value"
        }
      ]
    }''', result, true)
  }

  void 'one vulnerability with two sources'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD", [
        new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_NAME, "key", "value"), NOT_MARKED),
        new Range(1, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key2", "value2"), NOT_MARKED)
      ] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "A", "source": 1},
              {"value": "D"}
            ]
          },
          "hash":1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "origin": "http.request.parameter.name",
          "name": "key",
          "value": "value"
        },
        {
          "origin": "http.request.parameter",
          "name": "key2",
          "value": "value2"
        }
      ]
    }''', result, true)
  }

  void 'one vulnerability with no source type'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD", [new Range(0, 1, new Source(SourceTypes.NONE, "key", "value"), NOT_MARKED)] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "AD"}
            ]
          },
          "hash":1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ],
      "sources": [
        {
          "name": "key",
          "value": "value"
        }
      ]
    }''', result, true)
  }

  void 'two vulnerabilities with one shared source'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    final source = new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key", "value")
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD1", [new Range(0, 1, source, NOT_MARKED)] as Range[])
      ))
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD2", [new Range(0, 1, source, NOT_MARKED)] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "AD1"}
            ]
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        },
        {
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "AD2"}
            ]
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        }
      ],
      "sources": [
        {
          "name": "key",
          "origin": "http.request.parameter",
          "value": "value"
        }
      ]
    }''', result, true)
  }

  void 'two vulnerability with no shared sources'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD", [new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key1", "value"), NOT_MARKED)] as Range[])
      ))
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence("BAD", [new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key2", "value"), NOT_MARKED)] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 0},
              {"value": "AD"}
            ]
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        },
        {
          "evidence": {
            "valueParts": [
              {"value": "B", "source": 1},
              {"value": "AD"}
            ]
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        }
      ],
      "sources": [
        {
          "name": "key1",
          "origin": "http.request.parameter",
          "value": "value"
        },
        {
          "name": "key2",
          "origin": "http.request.parameter",
          "value": "value"
        }
      ]
    }''', result, true)
  }

  void 'one truncated vulnerability'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence(generateLargeString())
      ))

    when:
    final result = VulnerabilityEncoding.getExceededTagSizeJson(new TruncatedVulnerabilities(value.getVulnerabilities()))

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "type": "WEAK_HASH",
          "evidence": {
            "value": "MAX_SIZE_EXCEEDED"
          },
          "hash":1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          }
        }
      ]
    }''', result, true)
  }

  void 'two truncated vulnerabilities'() {
    given:
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence(generateLargeString(), [new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key1", "value"), NOT_MARKED)] as Range[])
      ))
    value.add(new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence(generateLargeString(), [new Range(0, 1, new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key2", "value"), NOT_MARKED)] as Range[])
      ))

    when:
    final result = VulnerabilityEncoding.getExceededTagSizeJson(new TruncatedVulnerabilities(value.getVulnerabilities()))

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
        {
          "evidence": {
            "value": "MAX_SIZE_EXCEEDED"
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        },
        {
          "evidence": {
            "value": "MAX_SIZE_EXCEEDED"
          },
          "hash": 1042880134,
          "location": {
            "spanId": 123456,
            "line": 1,
            "method": "fooMethod",
            "path": "foo"
          },
          "type": "WEAK_HASH"
        }
      ]
    }''', result, true)
  }

  void 'when json is greater than 25kb VulnerabilityEncoding#getExceededTagSizeJson is called'(){
    given:
    final metricCollector = Mock(IastMetricCollector)
    IastMetricCollector.register(metricCollector)
    final span = Stub(AgentSpan)
    final spanId = 123456
    span.getSpanId() >> spanId
    final value = new VulnerabilityBatch()
    for (int i = 0 ; i < 40; i++){
      value.add(generateBigVulnerability(span))
    }

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then: 'all sources have been removed and all vulnerabilities have generic evidence'
    !result.contains("source") //sources have been removed
    countGenericEvidenceOccurrences(result) == value.getVulnerabilities().size() //All the vulnerabilities have generic evidence
    1 * metricCollector.addMetric(IastMetric.JSON_TAG_SIZE_EXCEED, -1, 1)

  }

  void 'exception during serialization is caught'() {
    given:
    final value = new VulnerabilityBatch()
    final type = Stub(VulnerabilityType) {
      name() >> { throw new RuntimeException("ERROR") }
    }
    final vuln = new Vulnerability(type, null, null)
    value.add(vuln)

    when:
    final result = VulnerabilityEncoding.toJson(value)

    then:
    JSONAssert.assertEquals('''{
      "vulnerabilities": [
      ]
    }''', result, true)
  }

  private static String generateLargeString(){
    int targetSize = 25 * 1024
    StringBuilder sb = new StringBuilder()
    Random random = new Random()
    while (sb.length() < targetSize){
      sb.append(random.nextInt())
    }
    return sb.toString()
  }


  private static Vulnerability generateBigVulnerability(AgentSpan span){
    String largeString = generateLargeString()
    return new Vulnerability(
      VulnerabilityType.WEAK_HASH,
      Location.forSpanAndStack(span, new StackTraceElement("foo", "fooMethod", "foo", 1)),
      new Evidence(largeString, [
        new Range(0, largeString.length(), new Source(SourceTypes.REQUEST_PARAMETER_VALUE, "key2", largeString), NOT_MARKED)
      ] as Range[])
      )
  }

  private static int countGenericEvidenceOccurrences(final String input){
    Pattern pattern = Pattern.compile("\"evidence\":\\{\"value\":\"MAX_SIZE_EXCEEDED\"}")
    Matcher matcher = pattern.matcher(input)
    int count = 0
    while (matcher.find()){
      count++
    }
    return count
  }
}
