package datadog.trace.common.writer;

import static datadog.trace.api.Config.DEFAULT_AGENT_HOST;
import static datadog.trace.api.Config.DEFAULT_AGENT_UNIX_DOMAIN_SOCKET;
import static datadog.trace.api.Config.DEFAULT_TRACE_AGENT_PORT;
import static java.util.concurrent.TimeUnit.SECONDS;

import datadog.common.exec.DaemonThreadFactory;
import datadog.trace.common.writer.ddagent.DDAgentApi;
import datadog.trace.common.writer.ddagent.DDAgentResponseListener;
import datadog.trace.common.writer.ddagent.Monitor;
import datadog.trace.common.writer.ddagent.TraceSerializer;
import datadog.trace.core.DDSpan;
import datadog.trace.core.processor.TraceProcessor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * This writer buffers traces and sends them to the provided DDApi instance. Buffering is done with
 * a distruptor to limit blocking the application threads. Internally, the trace is serialized and
 * put onto a separate disruptor that does block to decouple the CPU intensive from the IO bound
 * threads.
 *
 * <p>[Application] -> [trace processing buffer] -> [serialized trace batching buffer] -> [dd-agent]
 *
 * <p>Note: the first buffer is non-blocking and will discard if full, the second is blocking and
 * will cause back pressure on the trace processing (serializing) thread.
 *
 * <p>If the buffer is filled traces are discarded before serializing. Once serialized every effort
 * is made to keep, to avoid wasting the serialization effort.
 */
@Slf4j
public class DDAgentWriter implements Writer {

  private static final int DISRUPTOR_BUFFER_SIZE = 1024;

  private final DDAgentApi api;
  private final TraceSerializer traceSerializer;
  private final ExecutorService traceProcessingExecutor;
  private final ArrayBlockingQueue<List<DDSpan>> queue;

  public final Monitor monitor;

  // Apply defaults to the class generated by lombok.
  public static class DDAgentWriterBuilder {
    String agentHost = DEFAULT_AGENT_HOST;
    int traceAgentPort = DEFAULT_TRACE_AGENT_PORT;
    String unixDomainSocket = DEFAULT_AGENT_UNIX_DOMAIN_SOCKET;
    int traceBufferSize = DISRUPTOR_BUFFER_SIZE;
    Monitor monitor = new Monitor.Noop();
    int flushFrequencySeconds = 1;
  }

  @Deprecated
  public DDAgentWriter() {
    this(
        new DDAgentApi(
            DEFAULT_AGENT_HOST, DEFAULT_TRACE_AGENT_PORT, DEFAULT_AGENT_UNIX_DOMAIN_SOCKET),
        new Monitor.Noop());
  }

  @Deprecated
  public DDAgentWriter(final DDAgentApi api, final Monitor monitor) {
    this.api = api;
    this.monitor = monitor;
    this.queue = new ArrayBlockingQueue<>(2048);
    // very bad: this escapes before the post-construction barrier :(
    this.traceSerializer = new TraceSerializer(api, monitor, queue, this, new TraceProcessor(), 1, SECONDS);
    this.traceProcessingExecutor = Executors.newSingleThreadExecutor(new DaemonThreadFactory("trace-processor"));
  }

  @lombok.Builder
  // These field names must be stable to ensure the builder api is stable.
  private DDAgentWriter(
      final DDAgentApi agentApi,
      final String agentHost,
      final int traceAgentPort,
      final String unixDomainSocket,
      final int traceBufferSize,
      final Monitor monitor,
      final int flushFrequencySeconds) {
    if (agentApi != null) {
      api = agentApi;
    } else {
      api = new DDAgentApi(agentHost, traceAgentPort, unixDomainSocket);
    }
    this.monitor = monitor;
    this.queue = new ArrayBlockingQueue<>(traceBufferSize);
    this.traceSerializer = new TraceSerializer(api, monitor, queue, this, new TraceProcessor(), flushFrequencySeconds, SECONDS);
    this.traceProcessingExecutor = Executors.newSingleThreadExecutor(new DaemonThreadFactory("trace-processor"));
  }

  public void addResponseListener(final DDAgentResponseListener listener) {
    api.addResponseListener(listener);
  }

  // Exposing some statistics for consumption by monitors
  public final long getDisruptorCapacity() {
    return 2048;
  }

  public final long getDisruptorUtilizedCapacity() {
    return getDisruptorCapacity() - getDisruptorRemainingCapacity();
  }

  public final long getDisruptorRemainingCapacity() {
    return 2048 - queue.size();
  }

  @Override
  public void write(final List<DDSpan> trace) {
    if (queue.offer(trace)) {
      monitor.onPublish(DDAgentWriter.this, trace);
    } else {
      traceSerializer.notifyDropped(1);
      log.debug("Trace written to overfilled buffer. Counted but dropping trace: {}", trace);
      monitor.onFailedPublish(this, trace);
    }
  }

  public boolean flush() {
    return false;
  }

  @Override
  public void incrementTraceCount() {
    traceSerializer.notifyUnreportedTraces(1);
  }

  public DDAgentApi getApi() {
    return api;
  }

  @Override
  public void start() {
    traceProcessingExecutor.submit(traceSerializer);
    monitor.onStart(this);
  }

  @Override
  public void close() {
    traceSerializer.close();
    // waits until processing task flushes its (bounded) input
    traceProcessingExecutor.shutdown();
    monitor.onShutdown(this, true);
  }

  @Override
  public String toString() {
    // DQH - I don't particularly like the instanceof check,
    // but I decided it was preferable to adding an isNoop method onto
    // Monitor or checking the result of Monitor#toString() to determine
    // if something is *probably* the NoopMonitor.

    String str = "DDAgentWriter { api=" + api;
    if (!(monitor instanceof Monitor.Noop)) {
      str += ", monitor=" + monitor;
    }
    str += " }";

    return str;
  }
}
