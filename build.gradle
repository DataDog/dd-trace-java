import java.nio.file.Paths

buildscript {
  dependencies {
    classpath "pl.allegro.tech.build:axion-release-plugin:1.14.4"
  }

  configurations.all {
    resolutionStrategy.dependencySubstitution {
      substitute module("com.jcraft:jsch") using module("com.github.mwiede:jsch:0.2.17") because "jcraft is unmaintained"
      substitute module("com.jcraft:jsch.agentproxy") using module("com.github.mwiede:jsch:0.2.17") because "jcraft is unmaintained"
      substitute module("com.jcraft:jzlib") using module("com.github.mwiede:jsch:0.2.17") because "jcraft is unmaintained"
    }
  }
}

plugins {
  id "datadog.dependency-locking"

  id "com.diffplug.spotless" version "6.13.0"
  id 'com.github.spotbugs' version '5.0.14'
  id "de.thetaphi.forbiddenapis" version "3.5.1"

  id 'pl.allegro.tech.build.axion-release' version '1.14.4'
  id 'io.github.gradle-nexus.publish-plugin' version '1.3.0'

  id "com.github.johnrengelman.shadow" version "7.1.2" apply false
  id "me.champeau.jmh" version "0.7.0" apply false
  id 'org.gradle.playframework' version '0.13' apply false
  id 'info.solidsoft.pitest' version '1.9.11'  apply false
}

description = 'dd-trace-java'

def isCI = System.getenv("CI") != null

apply from: "$rootDir/gradle/scm.gradle"
spotless {
  // only resolve the spotless dependencies once in the build
  predeclareDeps()
}
spotlessPredeclare {
  // these need to align with the types and versions in gradle/spotless.gradle
  java {
    // This is the last Google Java Format version that supports Java 8
    googleJavaFormat('1.7')
  }
  groovyGradle {
    greclipse()
  }
  groovy {
    greclipse()
  }
  kotlinGradle {
    ktlint('0.41.0')
  }
  kotlin {
    ktlint('0.41.0')
  }
  scala {
    scalafmt('2.7.5')
  }
}
apply from: "$rootDir/gradle/spotless.gradle"

def compileTask = tasks.register("compile")

allprojects {
  group = 'com.datadoghq'
  version = scmVersion.version

  if (isCI) {
    buildDir = "$rootDir/workspace/${projectDir.path.replace(rootDir.path, '')}/build/"
  }

  apply from: "$rootDir/gradle/dependencies.gradle"
  apply from: "$rootDir/gradle/util.gradle"

  compileTask.configure {
    dependsOn tasks.withType(AbstractCompile)
  }
}

repositories {
  mavenLocal()
  mavenCentral()
  gradlePluginPortal()
}

tasks.register("latestDepTest")

nexusPublishing {
  repositories {
    def forceLocal = project.hasProperty('forceLocal') && forceLocal
    if (forceLocal && !isCI) {
      local {
        // For testing use with https://hub.docker.com/r/sonatype/nexus
        // docker run --rm -d -p 8081:8081 --name nexus sonatype/nexus:oss
        // ./gradlew publishToLocal
        // Doesn't work for testing releases though... (due to staging)
        nexusUrl = uri("http://localhost:8081/nexus/content/repositories/releases/")
        snapshotRepositoryUrl = uri("http://localhost:8081/nexus/content/repositories/snapshots/")
        username = "admin"
        password = "admin123"
        allowInsecureProtocol = true
      }
    } else {
      sonatype {
        username = System.getenv("SONATYPE_USERNAME")
        password = System.getenv("SONATYPE_PASSWORD")
      }
    }
  }
}

wrapper {
  distributionType = Wrapper.DistributionType.ALL
}

tasks.register('writeMuzzleTasksToFile') {
  doLast {
    def muzzleFile = file("${buildDir}/muzzleTasks")
    assert muzzleFile.parentFile.mkdirs() || muzzleFile.parentFile.directory

    muzzleFile.text = subprojects.findAll { subproject -> subproject.plugins.hasPlugin('muzzle') }
    .collect { it.path + ":muzzle" }
    .join('\n')
  }
}

def writeMainVersionFileTask = tasks.register('writeMainVersionFile') {
  def versionFile = file("${rootProject.buildDir}/main.version")
  inputs.property "version", scmVersion.version
  outputs.file versionFile

  doFirst {
    assert versionFile.parentFile.mkdirs() || versionFile.parentFile.directory
    versionFile.text = "${inputs.properties.version}"
  }
}

allprojects {
  tasks.withType(JavaForkOptions).configureEach {
    maxHeapSize = System.properties["datadog.forkedMaxHeapSize"]
    minHeapSize = System.properties["datadog.forkedMinHeapSize"]
    jvmArgs "-XX:ErrorFile=/tmp/hs_err_pid%p.log"
    jvmArgs "-XX:+HeapDumpOnOutOfMemoryError"
    jvmArgs "-XX:HeapDumpPath=/tmp"
  }

  tasks.withType(PublishToMavenLocal).configureEach {
    it.finalizedBy(writeMainVersionFileTask)
  }
}

allprojects { project ->
  project.ext {
    activePartition = true
  }
  final boolean shouldUseTaskPartitions = project.rootProject.hasProperty("taskPartitionCount") && project.rootProject.hasProperty("taskPartition")
  if (shouldUseTaskPartitions) {
    final int taskPartitionCount = project.rootProject.property("taskPartitionCount") as int
    final int taskPartition = project.rootProject.property("taskPartition") as int
    final currentTaskPartition = Math.abs(project.path.hashCode() % taskPartitionCount)
    project.setProperty("activePartition", currentTaskPartition == taskPartition)
  }
}

Set<Task> getTaskDependenciesRecursive(Task baseTask, Set<Task> visited = []) {
  if (visited.contains(baseTask)) {
    return []
  }
  Set<Task> dependencies = [baseTask]
  visited.add(baseTask)
  for (td in baseTask.taskDependencies) {
    for (t in td.getDependencies(baseTask)) {
      dependencies.add(t)
      dependencies.addAll(getTaskDependenciesRecursive(t, visited))
    }
  }
  return dependencies
}

File relativeToGitRoot(File f) {
  return rootProject.projectDir.toPath().relativize(f.absoluteFile.toPath()).toFile()
}

String isAffectedBy(Task baseTask, Map<Project, Set<String>> affectedProjects) {
  for (Task t in getTaskDependenciesRecursive(baseTask)) {
    if (!affectedProjects.containsKey(t.project)) {
      continue
    }
    final Set<String> affectedTasks = affectedProjects.get(t.project)
    if (affectedTasks.contains("all")) {
      return "${t.project.path}:${t.name}"
    }
    if (affectedTasks.contains(t.name)) {
      return "${t.project.path}:${t.name}"
    }
  }
  return null
}

List<File> getChangedFiles(String baseRef, String newRef) {
  final stdout = new StringBuilder()
  final stderr = new StringBuilder()
  final proc = "git diff --name-only ${baseRef}..${newRef}".execute()
  proc.consumeProcessOutput(stdout, stderr)
  proc.waitForOrKill(1000)
  assert proc.exitValue() == 0, "git diff command failed, stderr: ${stderr}"
  def out = stdout.toString().trim()
  if (out.isEmpty()) {
    return []
  }
  logger.debug("git diff output: ${out}")
  return out.split("\n").collect {
    new File(rootProject.projectDir, it.trim())
  }
}

rootProject.ext {
  useGitChanges = false
}

if (rootProject.hasProperty("gitBaseRef")) {
  // -PgitBaseRef sets the base git reference to compare changes to. In CI, this should generally be set to the target
  // branch, usually master.
  final String baseRef = rootProject.property("gitBaseRef")
  // -PgitNewRef sets the new git new reference to compare changes to. This is useful for testing the test selection method
  // itself. Otherwise, comparing against current HEAD is what makes sense for CI.
  final String newRef = rootProject.hasProperty("gitNewRef") ? rootProject.property("gitNewRef") : "HEAD"

  rootProject.ext {
    it.changedFiles = getChangedFiles(baseRef, newRef)
    useGitChanges = true
  }

  // The ignoredFiles FileTree selects any file that should not trigger any tasks.
  final ignoredFiles = fileTree(rootProject.projectDir) {
    include '.gitingore', '.editorconfig'
    include '*.md', '**/*.md'
    include 'gradlew', 'gradlew.bat', 'mvnw', 'mvnw.cmd'
    include 'NOTICE'
    include 'static-analysis.datadog.yml'
  }
  rootProject.changedFiles.each { File f ->
    if (ignoredFiles.contains(f)) {
      logger.warn("Ignoring changed file: ${relativeToGitRoot(f)}")
    }
  }
  rootProject.changedFiles = rootProject.changedFiles.findAll { !ignoredFiles.contains(it) }

  // The globalEffectsFile FileTree selects any file that should trigger all tasks, regardless of gradle dependency
  // tracking.
  final globalEffectFiles = fileTree(rootProject.projectDir) {
    include '.circleci/**'
    include 'build.gradle'
    include 'gradle/**'
  }

  for (File f in rootProject.changedFiles) {
    if (globalEffectFiles.contains(f)) {
      logger.warn("Global effect change: ${relativeToGitRoot(f)} (no tasks will be skipped)")
      rootProject.useGitChanges = false
      break
    }
  }

  if (rootProject.useGitChanges) {
    logger.warn("Git change tracking is enabled, base: ${baseRef}")

    // Get all projects, sorted by descending path length.
    final projects = subprojects.sort { a, b -> b.projectDir.path.length() <=> a.projectDir.path.length() }
    for (File f in rootProject.changedFiles) {
      Project p = projects.find { f.toString().startsWith(it.projectDir.path + "/") }
      if (p == null) {
        logger.warn("Changed file: ${relativeToGitRoot(f)} at root project (no tasks will be skipped)")
        rootProject.useGitChanges = false
        break
      }
      final relPath = Paths.get(p.projectDir.path).relativize(f.toPath())
      final pathComponents = relPath.collect({ it.toString() }).toList()
      Map<Project, Set<String>> _affectedProjects = [:]
      if (pathComponents.size() < 3) {
        logger.warn("Changed file: ${relativeToGitRoot(f)} in project ${p.path} (all)")
        _affectedProjects.computeIfAbsent(p, { new HashSet<String>() }).add("all")
      } else if (pathComponents[0] == "src" && pathComponents[1] == "testFixturesClasses") {
        logger.warn("Changed file: ${relativeToGitRoot(f)} in project ${p.path} (testFixturesClasses)")
        _affectedProjects.computeIfAbsent(p, { new HashSet<String>() }).add("testFixturesClasses")
      } else if (pathComponents[0] == "src" && pathComponents[1] == "testClasses") {
        // TODO: We could include other variants here such as latestTest, etc.
        logger.warn("Changed file: ${relativeToGitRoot(f)} in project ${p.path} (testClasses)")
        _affectedProjects.computeIfAbsent(p, { new HashSet<String>() }).add("testClasses")
      } else if (pathComponents[0] == "src" && pathComponents[1] == "jmhCompileGeneratedClasses") {
        logger.warn("Changed file: ${relativeToGitRoot(f)} in project ${p.path} (jmhCompileGeneratedClasses)")
        _affectedProjects.computeIfAbsent(p, { new HashSet<String>() }).add("jmhCompileGeneratedClasses")
      } else {
        logger.warn("Changed file: ${relativeToGitRoot(f)} in project ${p.path} (all)")
        _affectedProjects.computeIfAbsent(p, { new HashSet<String>() }).add("all")
      }
      rootProject.ext {
        it.affectedProjects = _affectedProjects
      }
    }
  }

}

def testAggregate(String baseTaskName, includePrefixes, excludePrefixes, boolean forceCoverage = false) {
  def createRootTask = { String rootTaskName, String subProjTaskName ->
    def coverage = forceCoverage || rootProject.hasProperty("checkCoverage")
    tasks.register(rootTaskName) { aggTest ->
      subprojects { subproject ->
        if (subproject.property("activePartition") && includePrefixes.any { subproject.path.startsWith(it) } && !excludePrefixes.any { subproject.path.startsWith(it) }) {
          Task testTask = subproject.tasks.findByName(subProjTaskName)
          boolean isAffected = true
          if (testTask != null) {
            if (rootProject.useGitChanges) {
              final fileTrigger = isAffectedBy(testTask, rootProject.property("affectedProjects"))
              if (fileTrigger != null) {
                logger.warn("Selecting ${subproject.path}:${subProjTaskName} (triggered by ${fileTrigger})")
              } else {
                logger.warn("Skipping ${subproject.path}:${subProjTaskName} (not affected by changed files)")
                isAffected = false
              }
            }
            if (isAffected) {
              aggTest.dependsOn(testTask)
            }
          }
          if (isAffected && coverage) {
            def coverageTask = subproject.tasks.findByName("jacocoTestReport")
            if (coverageTask != null) {
              aggTest.dependsOn(coverageTask)
            }
            coverageTask = subproject.tasks.findByName("jacocoTestCoverageVerification")
            if (coverageTask != null) {
              aggTest.dependsOn(coverageTask)
            }
          }
        }
      }
    }
  }

  createRootTask "${baseTaskName}Test", 'allTests'
  createRootTask "${baseTaskName}LatestDepTest", 'allLatestDepTests'
  createRootTask "${baseTaskName}Check", 'check'
}

testAggregate("smoke", [":dd-smoke-tests"], [])
testAggregate("instrumentation", [":dd-java-agent:instrumentation"], [])
testAggregate("profiling", [":dd-java-agent:agent-profiling"], [])
testAggregate("debugger", [":dd-java-agent:agent-debugger"], [], true)
testAggregate("base", [":"], [
  ":dd-java-agent:instrumentation",
  ":dd-smoke-tests",
  ":dd-java-agent:agent-profiling",
  ":dd-java-agent:agent-debugger"
])
