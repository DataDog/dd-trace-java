#!/usr/bin/env python3

import json
import os
import sys
from io import StringIO

import numpy as np

from python_utils import import_benchmark_values, round_value

AGENT_MODULE = "Agent"
AGENT_START_MODULE = "Agent.start"
UOM = "µs"
CANDIDATE = os.getenv("CANDIDATE_VERSION")
BASELINE = os.getenv("BASELINE_VERSION")
TRACING_VARIANT = "tracing"

input_folder = sys.argv[1]


def _parse_benchmarks(folder: str, build: str, modules: list[str]) -> dict:
    benchmarks = dict()
    with open(f"{folder}/benchmark-{build}.json", "r", encoding="utf-8") as reader:
        benchmark_json = json.loads(reader.read())
    for benchmark in benchmark_json["benchmarks"]:
        parameters = benchmark["parameters"]
        module = parameters["module"]
        if module not in modules:
            modules.append(module)
        benchmarks[module] = import_benchmark_values(benchmark, "execution_time", UOM)
    return benchmarks


def _sort_variants(item: str) -> str:
    if item == TRACING_VARIANT:
        return ""
    return item


def _build_global_results(application: str, variants: list[str], values: dict) -> str:
    chart = StringIO()
    tables = {
        "baseline": StringIO(),
        "candidate": StringIO(),
    }
    tracing_means = {
        "baseline": {
            AGENT_MODULE: float(np.mean(values["baseline"][TRACING_VARIANT][AGENT_MODULE])),
            AGENT_START_MODULE: float(
                np.mean(values["baseline"][TRACING_VARIANT][AGENT_START_MODULE])
            ),
        },
        "candidate": {
            AGENT_MODULE: float(np.mean(values["candidate"][TRACING_VARIANT][AGENT_MODULE])),
            AGENT_START_MODULE: float(
                np.mean(values["candidate"][TRACING_VARIANT][AGENT_START_MODULE])
            ),
        },
    }

    chart.write(
        f"""
```mermaid
gantt
    title {application} - global startup overhead: candidate={CANDIDATE}, baseline={BASELINE}

    dateFormat X
    axisFormat %s
"""
    )
    for variant in variants:
        chart.write(f"section {variant}\n")
        for build in ("baseline", "candidate"):
            for module in (AGENT_START_MODULE, AGENT_MODULE):
                module_name = "Total" if module == AGENT_MODULE else "Agent"
                mean = float(np.mean(values[build][variant][module]))
                chart.write(f"{module_name} [{build}] ({round_value(mean, UOM)}) : 0, {round(mean)}\n")
    chart.write("```\n")

    for build in ("baseline", "candidate"):
        table = tables[build]
        table.write(f"\n|Module|Variant|Duration|Δ {TRACING_VARIANT}|\n")
        table.write("|---|---|---|---|\n")
        for module in (AGENT_START_MODULE, AGENT_MODULE):
            for variant in variants:
                tracing_mean = tracing_means[build][module]
                module_name = "Total" if module == AGENT_MODULE else "Agent"
                mean = float(np.mean(values[build][variant][module]))
                overhead = mean - tracing_mean
                overhead_pct = overhead * 100 / tracing_mean
                table.write(
                    f"|{module_name}|{variant}|{round_value(mean, UOM)}"
                    f"|{'-' if variant == TRACING_VARIANT else f'{round_value(overhead, UOM)} ({round(overhead_pct, 1)}%)'}|\n"
                )

    result = StringIO()
    result.write(chart.getvalue())
    for build, table in tables.items():
        result.write(f"\n* **{build}** results\n")
        result.write(table.getvalue())
    return result.getvalue()


def _build_module_results(application: str, module_names: list[str], variants: list[str], values: dict) -> str:
    result = StringIO()
    result.write(
        f"""
```mermaid
gantt
    title {application} - break down per module: candidate={CANDIDATE}, baseline={BASELINE}

    dateFormat X
    axisFormat %s
"""
    )
    for variant in variants:
        result.write(f"section {variant}\n")
        for module in module_names:
            if module not in (AGENT_START_MODULE, AGENT_MODULE):
                for build in ("baseline", "candidate"):
                    variant_values = values[build][variant]
                    if module in variant_values:
                        module_values = variant_values[module]
                        mean = float(np.mean(module_values))
                        result.write(f"{module} [{build}] ({round_value(mean, UOM)}) : 0, {round(mean)}\n")

    result.write("```\n")
    return result.getvalue()


def _build_application_results(folder: str) -> str:
    application = os.path.basename(folder)
    module_names = list()
    values = {
        "baseline": dict(),
        "candidate": dict(),
    }
    for variant_folder in [f.path for f in os.scandir(folder) if f.is_dir()]:
        variant = os.path.basename(variant_folder)
        values["candidate"][variant] = _parse_benchmarks(variant_folder, "candidate", module_names)
        values["baseline"][variant] = _parse_benchmarks(variant_folder, "baseline", module_names)
    variants = sorted(values["candidate"].keys(), key=_sort_variants)
    result = StringIO()
    result.write(f"\n\n<details><summary>Startup time reports for {application}</summary>\n")
    result.write(_build_global_results(application, variants, values))
    result.write(_build_module_results(application, module_names, variants, values))
    result.write("\n</details>\n")
    return result.getvalue()


for application_folder in [f.path for f in os.scandir(input_folder) if f.is_dir()]:
    print(_build_application_results(application_folder))
