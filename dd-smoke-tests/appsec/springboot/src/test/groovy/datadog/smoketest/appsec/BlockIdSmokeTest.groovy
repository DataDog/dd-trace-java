package datadog.smoketest.appsec

import datadog.trace.agent.test.utils.OkHttpUtils
import okhttp3.Request
import spock.lang.Shared

import java.util.regex.Pattern

/**
 * Smoke test to verify that block_id (UUIDv4 generated by libddwaf v18.0.0)
 * is correctly extracted and included in blocking responses.
 *
 * Per RFC-1070, libddwaf v18.0.0+ generates a UUIDv4 as block_id in action
 * parameters. This test verifies that:
 * - block_id is extracted from libddwaf action parameters
 * - block_id is included in JSON blocking responses as "block_id" field
 * - block_id is included in HTML blocking responses as placeholder replacement
 * - block_id placeholder {block_id} is replaced in custom redirect URLs
 */
class BlockIdSmokeTest extends AbstractAppSecServerSmokeTest {

  @Shared
  String buildDir = new File(System.getProperty("datadog.smoketest.builddir")).absolutePath
  @Shared
  String customRulesPath = "${buildDir}/appsec_blockid_rules.json"

  // UUID v4 pattern: 8-4-4-4-12 hexadecimal characters
  private static final Pattern UUID_PATTERN = Pattern.compile(
  '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'
  )

  def prepareCustomConfiguration() {
    // Create custom rules with custom actions to test block_id
    def customRules = [
      [
        id: '__test_block_id_trigger',
        name: 'Block ID Test Rule',
        tags: [
          type: 'block_test',
          category: 'attack_attempt'
        ],
        conditions: [
          [
            parameters: [
              inputs: [[address: 'server.request.headers.no_cookies']],
              key_path: ['user-agent'],
              regex: 'BlockIdTestAgent.*'
            ],
            operator: 'match_regex'
          ]
        ],
        transformers: ['lowercase'],
        on_match: ['block_action']
      ],
      [
        id: '__test_block_id_redirect_no_placeholder',
        name: 'Block ID Redirect Test Rule Without Placeholder',
        tags: [
          type: 'redirect_test_no_placeholder',
          category: 'attack_attempt'
        ],
        conditions: [
          [
            parameters: [
              inputs: [[address: 'server.request.headers.no_cookies']],
              key_path: ['user-agent'],
              regex: 'RedirectTestAgent.*'
            ],
            operator: 'match_regex'
          ]
        ],
        transformers: ['lowercase'],
        on_match: ['redirect_action_no_placeholder']
      ]
    ]

    def customActions = [
      [
        id: 'block_action',
        type: 'block_request',
        parameters: [
          status_code: 403,
          type: 'auto'
        ]
      ],
      [
        id: 'redirect_action_no_placeholder',
        type: 'redirect_request',
        parameters: [
          status_code: 303,
          location: 'https://custom.example.com/redirect'
        ]
      ]
    ]

    // Write the custom configuration using mergeRules
    mergeRules(customRulesPath, customRules, customActions)
  }

  @Override
  ProcessBuilder createProcessBuilder() {
    // Prepare custom configuration before starting the process
    prepareCustomConfiguration()

    String springBootShadowJar = System.getProperty("datadog.smoketest.appsec.springboot.shadowJar.path")

    List<String> command = new ArrayList<>()
    command.add(javaPath())
    command.addAll(defaultJavaProperties)
    command.addAll(defaultAppSecProperties)
    command.addAll((String[]) ["-jar", springBootShadowJar, "--server.port=${httpPort}"])

    ProcessBuilder processBuilder = new ProcessBuilder(command)
    processBuilder.directory(new File(buildDirectory))
  }

  void 'test block_id is present in JSON blocking response'() {
    given: 'a request that triggers blocking'
    def url = "http://localhost:${httpPort}/greeting"
    def client = OkHttpUtils.clientBuilder().build()
    def request = new Request.Builder()
      .url(url)
      .header('User-Agent', 'BlockIdTestAgent/1.0')
      .header('Accept', 'application/json')
      .get()
      .build()

    when: 'the request is sent'
    def response = client.newCall(request).execute()

    then: 'the request is blocked with 403'
    response.code() == 403

    and: 'the response is JSON'
    response.header('Content-Type').contains('application/json')

    and: 'the response body contains block_id with valid UUID format'
    def body = response.body().string()
    body.contains('"block_id"')
    def matcher = UUID_PATTERN.matcher(body)
    assert matcher.find(), "block_id with valid UUID format not found in response: ${body}"

    // Verify it's in the expected JSON structure
    body.contains('"errors"')
    body.contains('"You\'ve been blocked"')
  }

  void 'test block_id is present in HTML blocking response'() {
    given: 'a request that triggers blocking'
    def url = "http://localhost:${httpPort}/greeting"
    def client = OkHttpUtils.clientBuilder().build()
    def request = new Request.Builder()
      .url(url)
      .header('User-Agent', 'BlockIdTestAgent/1.0')
      .header('Accept', 'text/html')
      .get()
      .build()

    when: 'the request is sent'
    def response = client.newCall(request).execute()

    then: 'the request is blocked with 403'
    response.code() == 403

    and: 'the response is HTML'
    response.header('Content-Type').contains('text/html')

    and: 'the response body contains block_id with valid UUID format'
    def body = response.body().string()
    body.contains('Event ID:')
    def matcher = UUID_PATTERN.matcher(body)
    assert matcher.find(), "block_id with valid UUID format not found in response: ${body}"

    // Verify the placeholder {block_id} was replaced (should not be present)
    assert !body.contains('{block_id}'), "Placeholder {block_id} was not replaced in HTML response"

    // Verify it's in the expected HTML structure
    body.contains('You\'ve been blocked')
    body.contains('<html')
  }

  void 'test redirect without placeholder does not add block_id'() {
    given: 'a request that triggers redirect without placeholder'
    def url = "http://localhost:${httpPort}/greeting"
    def client = OkHttpUtils.clientBuilder()
      .followRedirects(false) // Don't follow redirects automatically
      .build()
    def request = new Request.Builder()
      .url(url)
      .header('User-Agent', 'RedirectTestAgent/1.0')
      .get()
      .build()

    when: 'the request is sent'
    def response = client.newCall(request).execute()

    then: 'the request is redirected with 303'
    response.code() == 303

    and: 'the Location header contains the unmodified redirect URL without block_id'
    def location = response.header('Location')
    assert location != null, 'Location header not present in redirect response'
    assert location == 'https://custom.example.com/redirect', "URL should not be modified: ${location}"

    // Verify block_id was NOT added to the URL
    assert !location.contains('block_id'), "block_id should not be added when placeholder is not present: ${location}"
  }

  void 'test block_id format is consistent across requests'() {
    given: 'multiple blocking requests'
    def url = "http://localhost:${httpPort}/greeting"
    def client = OkHttpUtils.clientBuilder().build()
    def request = new Request.Builder()
      .url(url)
      .header('User-Agent', 'BlockIdTestAgent/1.0')
      .header('Accept', 'application/json')
      .get()
      .build()

    when: 'the first request is sent'
    def response1 = client.newCall(request).execute()
    def body1 = response1.body().string()
    def matcher1 = UUID_PATTERN.matcher(body1)
    matcher1.find()
    def blockId1 = matcher1.group()

    and: 'a second request is sent'
    def response2 = client.newCall(request).execute()
    def body2 = response2.body().string()
    def matcher2 = UUID_PATTERN.matcher(body2)
    matcher2.find()
    def blockId2 = matcher2.group()

    then: 'both requests return valid block_ids'
    response1.code() == 403
    response2.code() == 403
    blockId1 != null
    blockId2 != null

    and: 'each block_id is unique (different UUIDs for different requests)'
    blockId1 != blockId2

    and: 'both follow UUID v4 format'
    UUID_PATTERN.matcher(blockId1).matches()
    UUID_PATTERN.matcher(blockId2).matches()
  }
}
