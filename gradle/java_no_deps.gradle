import datadog.gradle.plugin.testJvmConstraints.TestJvmConstraintsExtension
import groovy.transform.CompileStatic
import datadog.gradle.plugin.testJvmConstraints.ProvideJvmArgsOnJvmLauncherVersion

apply plugin: 'java-library'
apply plugin: 'datadog.test-jvm-contraints'

apply from: "$rootDir/gradle/codenarc.gradle"
apply from: "$rootDir/gradle/forbiddenapis.gradle"
apply from: "$rootDir/gradle/spotless.gradle"
apply from: "$rootDir/gradle/spotbugs.gradle"
apply from: "$rootDir/gradle/repositories.gradle"
apply from: "$rootDir/gradle/test-suites.gradle"

// Glue code for Groovy DSL.
// TODO this extension need to go away once we move to convention plugins
ext.configureCompiler = (AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) -> {
  configureCompiler(it, toolchainVersion, compatibilityVersion, unsetReleaseFlagReason)
} as Closure<Void>

@CompileStatic
class TracerJavaExtension {
  public static String NAME = "tracerJava";
  private Project project

  Property<Boolean> skipSettingTestJavaVersion

  TracerJavaExtension(ObjectFactory objects, ProviderFactory providers, Project project) {
    this.project = project
    this.skipSettingTestJavaVersion = objects.property(Boolean).convention(providers.provider { project.findProperty('skipSettingTestJavaVersion') as Boolean })
  }

  /**
   * Adds the source set `src/main/javaXX`, configures its compilation and its test jvm constraints.
   *
   * @param javaVersion The wanted java version for these source.
   * @param compileOnly Whether the compilation output is added as compileOnly.
   * @return
   */
  def addSourceSetFor(JavaVersion javaVersion, Boolean compileOnly = false) {
    project.extensions.getByType(TestJvmConstraintsExtension).minJavaVersionForTests.set(javaVersion)

    def version = javaVersion
    def name = "java${version.majorVersion}"
    def sourceSets = project.extensions.getByType(SourceSetContainer)

    def mainForJavaVersionSourceSet = sourceSets.create("${SourceSet.MAIN_SOURCE_SET_NAME}_$name") {
      (it as SourceSet).java.srcDirs = ["${project.projectDir}/src/${SourceSet.MAIN_SOURCE_SET_NAME}/$name"]
    }

    project.tasks.named(mainForJavaVersionSourceSet.compileJavaTaskName, JavaCompile) {
      // TODO Make 'configureCompiler' a general utility method
      def cl = project.extensions.getByType(ExtraPropertiesExtension).get("configureCompiler") as Closure
      cl.call(it, version.majorVersion.toInteger().intValue(), version)
    }

    // "socket-utils" is only set to compileOnly because the implementation dependency incorrectly adds Java17 classes to all jar prefixes.
    // This causes the AgentJarIndex to search for other non-Java17 classes in the wrong prefix location and fail to resolve class names.
    if (compileOnly) {
      project.dependencies.add("compileOnly", mainForJavaVersionSourceSet.output)
    } else {
      project.dependencies.add("compileOnly", project.files(mainForJavaVersionSourceSet.compileClasspath))
      project.dependencies.add("implementation", mainForJavaVersionSourceSet.output)
    }

    project.tasks.named("jar", Jar) {
      it.from(mainForJavaVersionSourceSet.output)
    }
  }
}
def tracerJavaExtension = extensions.create(TracerJavaExtension.NAME, TracerJavaExtension, objects, providers, project)



// Only run one testcontainers test at a time
ext.testcontainersLimit = gradle.sharedServices.registerIfAbsent("testcontainersLimit", BuildService) {
  maxParallelUsages = 1
}

// Task for tests that want to run forked in their own separate JVM
if (tasks.matching({ it.name == 'forkedTest' }).empty) {
  tasks.register('forkedTest', Test) {
    useJUnitPlatform()
  }
}

def applyCodeCoverage = !(
  project.path.startsWith(":dd-smoke-tests") ||
  project.path == ":dd-java-agent" ||
  project.path == ":dd-java-agent:load-generator" ||
  project.path.startsWith(":dd-java-agent:benchmark") ||
  project.path.startsWith(":dd-java-agent:instrumentation") ||
  project.path.startsWith(":dd-java-agent:appsec:weblog:"))

ext.applyCodeCoverage = applyCodeCoverage

// https://stackoverflow.com/questions/42501869/gradle-skip-jacoco-during-test
// https://poetengineer.postach.io/post/how-to-conditionally-enable-disable-jacoco-in-gradle-build
if (applyCodeCoverage) {
  apply from: "$rootDir/gradle/jacoco.gradle"
}

java {
  // Our minimum target
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8

  // See https://docs.gradle.org/current/userguide/upgrading_version_5.html, Automatic target JVM version
  disableAutoTargetJvm()
  withJavadocJar()
  withSourcesJar()
}

if (project.hasProperty('minJavaVersionForTests') && project.findProperty('minJavaVersionForTests') != JavaVersion.VERSION_1_7) {
  tracerJavaExtension.addSourceSetFor(project.findProperty('minJavaVersionForTests'))

  // TODO configure this via extension
  //  If unset (hasProperty is false), or value is explicitly set to false (case not seen), then
  //  sets the compiler to `minJavaVersionForTests` version
  // In some cases we would like to avoid setting java version to `minJavaVersionForTests`.
  // For example we would like to be able to run profiling tests with ZULU8, but we cannot run it with other JDK8 implementations at the moment
  def skipSettingTestJavaVersion = project.hasProperty('skipSettingTestJavaVersion') && project.findProperty('skipSettingTestJavaVersion')
  if (!skipSettingTestJavaVersion) {
    tasks.withType(JavaCompile).configureEach {
      if (it.name.toLowerCase().contains("test")) {
        sourceCompatibility = version
        targetCompatibility = version
      }
    }
  }
}

tasks.named("jar", Jar) {
  /**
   Make Jar build fail on duplicate files
   By default Gradle Jar task can put multiple files with the same name
   into a Jar. This may lead to confusion. For example if auto-service
   annotation processing creates files with same name in `scala` and
   `java` directory this would result in Jar having two files with the
   same name in it. Which in turn would result in only one of those
   files being actually considered when that Jar is used leading to very
   confusing failures.
   Instead we should 'fail early' and avoid building such Jars.
   */
  duplicatesStrategy = DuplicatesStrategy.FAIL

  manifest {
    attributes(
      "Implementation-Title": project.name,
      "Implementation-Version": project.version,
      "Implementation-Vendor": "Datadog",
      "Implementation-URL": "https://github.com/datadog/dd-trace-java",
      )
  }
}

tasks.withType(Javadoc).configureEach {
  options.encoding = "utf-8"
  options.docEncoding = "utf-8"
  options.charSet = "utf-8"

  options.addStringOption('Xdoclint:none', '-quiet')

  doFirst {
    if (project.ext.has("apiLinks")) {
      options.links(*project.apiLinks)
    }
  }
}

tasks.named("javadoc", Javadoc) {
  source = sourceSets.main.java.srcDirs
  classpath = configurations.compileClasspath

  options {
    setMemberLevel(JavadocMemberLevel.PUBLIC)
    setAuthor(true)

    links = ["https://docs.oracle.com/javase/8/docs/api/"]
    source = 8
  }
}

ext.configureJvmArgs = (Test testTask, JavaVersion applyFromVersion, List<String> jvmArgsToApply, Provider<Boolean> additionalCondition = null) -> {
  testTask.jvmArgumentProviders.add(new ProvideJvmArgsOnJvmLauncherVersion(
  testTask,
  applyFromVersion,
  jvmArgsToApply,
  additionalCondition ?: testTask.project.providers.provider { true }
  ))
}

// TODO move to test-suites config ?
tasks.withType(Test).configureEach { Test testTask ->
  if (configurations.hasProperty("latestDepTestRuntimeClasspath")) {
    doFirst {
      def testArtifacts = configurations.testRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      def latestTestArtifacts = configurations.latestDepTestRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      assert testArtifacts != latestTestArtifacts: "latestDepTest dependencies are identical to test"
    }
  }
}


[JavaCompile, ScalaCompile, GroovyCompile].each { type ->
  tasks.withType(type).configureEach {
    if (options.fork) {
      options.forkOptions.with {
        memoryMaximumSize = "256M"
      }
    }
  }
}

if (project.plugins.hasPlugin('kotlin')) {
  ['compileKotlin', 'compileTestKotlin'].each { type ->
    tasks.named(type) {
      kotlinDaemonJvmArguments = ["-Xmx256m", "-XX:+UseParallelGC"]
    }
  }
}

tasks.withType(JavaExec).configureEach {
  if (!it.maxHeapSize) {
    it.maxHeapSize = '256M'
  }
}

// For reproducible builds
tasks.withType(AbstractArchiveTask).configureEach {
  preserveFileTimestamps = false
  reproducibleFileOrder = true
}

project.pluginManager.withPlugin('com.gradleup.shadow') {
  // Remove the no-deps jar from the archives to prevent publication
  // Also removes other distribution types (zip, tar etc.), only affects project in dd-smoke-tests
  configurations {
    named("archives") {
      outgoing.artifacts.clear()
      outgoing.artifact(project.tasks.named("shadowJar"))
    }
  }
}

if (project.hasProperty("removeJarVersionNumbers") && project.findProperty("removeJarVersionNumbers").asBoolean()) {
  tasks.withType(AbstractArchiveTask).configureEach {
    archiveVersion.unsetConvention()
    archiveVersion.set(null)
  }
}

// Configure the compile task with release if possible
// other wise use the java 8 compiler
tasks.withType(JavaCompile).configureEach {
  def targetVersion = JavaVersion.toVersion(targetCompatibility).majorVersion as Integer
  if (JavaVersion.current().isJava9Compatible()) {
    it.options.release = targetVersion
    // Disable '-options' because we are compiling for java8 from the daemon JDK deliberately
    it.options.compilerArgs.add('-Xlint:-options')
  } else {
    it.javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(targetVersion)
    }
  }
  doFirst("audit-compiler-setting") {
    def releaseFlagValue = options.release.getOrNull()
    if (releaseFlagValue != null && !JavaVersion.toVersion(targetCompatibility).isCompatibleWith(JavaVersion.toVersion(releaseFlagValue))) {
      logger.warn('⚠️ The release flag and targetCompatibility have different values **release will win**, targetCompatibility: ' + targetCompatibility.toString() + ', release: ' + releaseFlagValue + '\n' +
      '  compiler: ' + javaCompiler.get().executablePath.asFile)
    }
  }
}

/**
 * Customize the compiler config.
 * Adapts depending on the compile task type (java, groovy, scala covered).
 * For java changes the compiler from the toolchain, and adapts its configuration.
 *
 * For Groovy and Scala compile tasks only sets the launcher.
 *
 * NOTE: This function is exposed via a closure
 */
def configureCompiler(AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) {
  Provider<JavaCompiler> compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  Provider<JavaLauncher> launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  try {
    if (it instanceof JavaCompile) {
      JavaCompile jc = (JavaCompile) it
      jc.javaCompiler = compiler
      if (compatibilityVersion != null) {
        jc.targetCompatibility = compatibilityVersion
        jc.sourceCompatibility = compatibilityVersion
      }
      def isReleaseFlagIncompatibleWithTarget = compatibilityVersion != null
      && !compatibilityVersion.isCompatibleWith(JavaVersion.toVersion(toolchainVersion))
      if (unsetReleaseFlagReason != null || isReleaseFlagIncompatibleWithTarget || toolchainVersion == 8) {
        logger.debug("Not using --release for {}", jc.path)
        // Don't set the release flag, as code need unpublished symbols,
        // those are not accessible when using `--release N`
        // e.g. with sun.misc.SharedSecrets, or jdk.jfr.internal.JVM
        jc.options.release = null
        if (unsetReleaseFlagReason != null) {
          logger.info("Not using '--release' because: {}", unsetReleaseFlagReason)
        }
      } else if (JavaVersion.toVersion(toolchainVersion).isJava9Compatible()) {
        jc.options.release = toolchainVersion
        jc.options.compilerArgs.add('-Xlint:-options')
      }
    } else if (it instanceof GroovyCompile) {
      GroovyCompile gc = (GroovyCompile) it
      gc.javaLauncher = launcher
      if (compatibilityVersion != null) {
        it.sourceCompatibility = compatibilityVersion
        it.targetCompatibility = compatibilityVersion
      }
      if (unsetReleaseFlagReason != null) {
        logger.info("Using specific toolchain because: {}", unsetReleaseFlagReason)
      }
    } else if (it instanceof ScalaCompile) {
      ScalaCompile sc = (ScalaCompile) it
      sc.javaLauncher = launcher
    } else {
      throw new GradleException("Unsupported compile type: ${it.getClass()}")
    }
  } catch (NoSuchElementException ignored) {
    throw new GradleException("Unable to find compiler for Java $toolchainVersion. Have you set JAVA_${toolchainVersion}_HOME?")
  }
}

ext.configureGroovyCompiler = (int toolchainVersion, String... taskNames) -> {
  taskNames.each { taskName ->
    tasks.named(taskName, GroovyCompile) {
      configureCompiler(it, toolchainVersion)
    }
  }
} as Closure<Void>

ext.getJavaLauncherFor = (javaVersionInteger) -> {
  def launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(javaVersionInteger)
  }
  if (!launcher.present) {
    throw new GradleException("Unable to find launcher for Java $javaVersionInteger. Have you set JAVA_${javaVersionInteger}_HOME?")
  }
  return launcher
} as Closure<Provider<JavaLauncher>>


tasks.register('testJar', Jar) {
  dependsOn(testClasses)
  from(sourceSets.test.output)
  archiveClassifier = 'test'
}

apply from: "$rootDir/gradle/configure_tests.gradle"
