import java.nio.file.Files
import java.nio.file.Paths
import org.gradle.api.internal.provider.PropertyFactory
import org.gradle.jvm.toolchain.internal.SpecificInstallationToolchainSpec

apply plugin: 'datadog.configure-tests'
apply plugin: 'java-library'

apply from: "$rootDir/gradle/codenarc.gradle"
apply from: "$rootDir/gradle/forbiddenapis.gradle"
apply from: "$rootDir/gradle/spotless.gradle"
apply from: "$rootDir/gradle/spotbugs.gradle"
apply from: "$rootDir/gradle/repositories.gradle"
apply from: "$rootDir/gradle/test-suites.gradle"

// Only run one testcontainers test at a time
ext.testcontainersLimit = gradle.sharedServices.registerIfAbsent("testcontainersLimit", BuildService) {
  maxParallelUsages = 1
}

// Task for tests that want to run forked in their own separate JVM
if (tasks.matching({ it.name == 'forkedTest' }).empty) {
  tasks.register('forkedTest', Test) {
    useJUnitPlatform()
  }
}

def applyCodeCoverage = !(
  project.path.startsWith(":dd-smoke-tests") ||
  project.path == ":dd-java-agent" ||
  project.path == ":dd-java-agent:load-generator" ||
  project.path.startsWith(":dd-java-agent:benchmark") ||
  project.path.startsWith(":dd-java-agent:instrumentation") ||
  project.path.startsWith(":dd-java-agent:appsec:weblog:"))

if (applyCodeCoverage) {
  apply from: "$rootDir/gradle/jacoco.gradle"
}

java {
  // Our minimum target
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8

  // See https://docs.gradle.org/current/userguide/upgrading_version_5.html, Automatic target JVM version
  disableAutoTargetJvm()
  withJavadocJar()
  withSourcesJar()
}

if (project.hasProperty('minJavaVersionForTests') && project.findProperty('minJavaVersionForTests') != JavaVersion.VERSION_1_7) {
  def version = JavaVersion.toVersion(project.findProperty('minJavaVersionForTests'))
  def name = "java${version.majorVersion}"
  def mainForJavaVersionSourceSet = sourceSets.create("main_$name") {
    java.srcDirs = ["${project.projectDir}/src/main/$name"]
  }

  // Task name is registered when source set was created
  tasks.named(mainForJavaVersionSourceSet.compileJavaTaskName, JavaCompile) {
    configureCompiler(it, version.majorVersion.toInteger().intValue(), version)
  }

  // "socket-utils" is only set to compileOnly because the implementation dependency incorrectly adds Java17 classes to all jar prefixes.
  // This causes the AgentJarIndex to search for other non-Java17 classes in the wrong prefix location and fail to resolve class names.
  dependencies {
    if ("${project.projectDir}".endsWith("socket-utils")) {
      compileOnly(files(project.sourceSets."main_$name".output))
    } else {
      compileOnly(files(project.sourceSets."main_$name".compileClasspath))
      implementation(files(project.sourceSets."main_$name".output))
    }
  }

  tasks.named("jar", Jar) {
    from sourceSets."main_$name".output
  }

  // In some cases we would like to avoid setting java version to `minJavaVersionForTests`.
  // For example we would like to be able to run profiling tests with ZULU8, but we cannot run it with other JDK8 implementations at the moment
  def skipSettingTestJavaVersion = project.hasProperty('skipSettingTestJavaVersion') && project.findProperty('skipSettingTestJavaVersion')
  if (!skipSettingTestJavaVersion) {
    tasks.withType(JavaCompile).configureEach {
      if (it.name.toLowerCase().contains("test")) {
        sourceCompatibility = version
        targetCompatibility = version
      }
    }
  }
}

tasks.named("jar", Jar) {
  /**
   Make Jar build fail on duplicate files
   By default Gradle Jar task can put multiple files with the same name
   into a Jar. This may lead to confusion. For example if auto-service
   annotation processing creates files with same name in `scala` and
   `java` directory this would result in Jar having two files with the
   same name in it. Which in turn would result in only one of those
   files being actually considered when that Jar is used leading to very
   confusing failures.
   Instead we should 'fail early' and avoid building such Jars.
   */
  duplicatesStrategy = DuplicatesStrategy.FAIL

  manifest {
    attributes(
      "Implementation-Title": project.name,
      "Implementation-Version": project.version,
      "Implementation-Vendor": "Datadog",
      "Implementation-URL": "https://github.com/datadog/dd-trace-java",
      )
  }
}

tasks.withType(Javadoc).configureEach {
  options.encoding = "utf-8"
  options.docEncoding = "utf-8"
  options.charSet = "utf-8"

  options.addStringOption('Xdoclint:none', '-quiet')

  doFirst {
    if (project.ext.has("apiLinks")) {
      options.links(*project.apiLinks)
    }
  }
}

tasks.named("javadoc", Javadoc) {
  source = sourceSets.main.java.srcDirs
  classpath = configurations.compileClasspath

  options {
    setMemberLevel(JavadocMemberLevel.PUBLIC)
    setAuthor(true)

    links = ["https://docs.oracle.com/javase/8/docs/api/"]
    source = 8
  }
}

class ProvideJvmArgsOnJvmLauncherVersion implements CommandLineArgumentProvider {
  @Internal
  Test test
  @Input
  JavaVersion applyFromVersion
  @Input
  List<String> jvmArgsToApply
  @Input
  Provider<Boolean> additionalCondition

  ProvideJvmArgsOnJvmLauncherVersion(Test test, JavaVersion applyFromVersion, List<String> jvmArgsToApply, Provider<Boolean> additionalCondition) {
    this.test = test
    this.applyFromVersion = applyFromVersion
    this.jvmArgsToApply = jvmArgsToApply
    this.additionalCondition = additionalCondition
  }

  @Override
  Iterable<String> asArguments() {
    def launcherVersion = test.javaLauncher.map { JavaVersion.toVersion(it.metadata.languageVersion.asInt()) }
    .orElse(JavaVersion.current())
    .get()

    if (launcherVersion.isCompatibleWith(applyFromVersion) && additionalCondition.getOrElse(true)) {
      jvmArgsToApply
    } else {
      []
    }
  }
}
ext.configureJvmArgs = (Test testTask, JavaVersion applyFromVersion, List<String> jvmArgsToApply, Provider<Boolean> additionalCondition = null) -> {
  testTask.jvmArgumentProviders.add(new ProvideJvmArgsOnJvmLauncherVersion(
  testTask,
  applyFromVersion,
  jvmArgsToApply,
  additionalCondition ?: testTask.project.providers.provider { true }
  ))
}


def configureTestJvm(Project project, boolean applyCodeCoverage) {
  def currentJavaHomePath = getJavaHomePath(System.getProperty("java.home"))
  def normalizedTestJvm = project.providers.gradleProperty("testJvm").map { testJvm ->
    if (testJvm.isBlank()) {
      throw new GradleException("testJvm property is blank")
    }

    // "stable" is calculated as the largest X found in JAVA_X_HOME
    if (testJvm == "stable") {
      def javaVersions = providers.environmentVariablesPrefixedBy("JAVA_").map { javaHomes ->
        javaHomes
        .findAll { it.key =~ /^JAVA_[0-9]+_HOME$/ }
        .collect { (it.key =~ /^JAVA_(\d+)_HOME$/)[0][1] as Integer }
      }.get()

      if (javaVersions.isEmpty()) {
        throw new GradleException("No valid JAVA_X_HOME environment variables found.")
      }

      javaVersions.max().toString()
    } else {
      testJvm
    }
  }.map { logger.info("normalized testJvm: " + it); it }

  def testJvmHomePath = normalizedTestJvm.map {
    if (Files.exists(Paths.get(it))) {
      getJavaHomePath(it)
    } else {
      def matcher = it =~ /([a-zA-Z]*)([0-9]+)/
      if (!matcher.matches()) {
        throw new GradleException("Unable to find launcher for Java '$it'. It needs to match '([a-zA-Z]*)([0-9]+)'.")
      }
      def testJvmLanguageVersion = matcher.group(2) as Integer
      def testJvmEnv = "JAVA_${it}_HOME"
      def testJvmHome = providers.environmentVariable(testJvmEnv).orNull
      if (!testJvmHome) {
        throw new GradleException("Unable to find launcher for Java '$it'. Have you set '$testJvmEnv'?")
      }

      getJavaHomePath(testJvmHome)
    }
  }.map { logger.info("testJvm home path: " + it); it }

  def javaTestLauncher = testJvmHomePath.zip(normalizedTestJvm) { testJvmHome, testJvm ->
    // Only change test JVM if it's not the one we are running the gradle build with
    if (currentJavaHomePath == testJvmHome) {
      null
    } else {
      def jvmSpec = new SpecificInstallationToolchainSpec(project.services.get(PropertyFactory), file(testJvmHome))
      // The provider always says that a value is present so we need to wrap it for proper error messages

      javaToolchains.launcherFor(jvmSpec).orElse(providers.provider {
        throw new GradleException("Unable to find launcher for Java $testJvm. Does '$testJvmHome' point to a JDK?")
      })
    }
  }.flatMap { it }.map { logger.info("testJvm launcher: " + it.executablePath); it }

  // Apply the launcher
  tasks.withType(Test).configureEach { Test testTask ->
    if (javaTestLauncher.isPresent()) {
      javaLauncher = javaTestLauncher
      onlyIf("Allowed or forced JDK") {
        !isJdkExcluded(normalizedTestJvm.get()) &&
        (isJavaLanguageVersionAllowed(javaTestLauncher.get().metadata.languageVersion, it.name) || isJdkForced(normalizedTestJvm.get()))
      }

      // Disable jacoco for additional 'testJvm' tests to speed things up a bit
      if (applyCodeCoverage) {
        jacoco {
          enabled = false
        }
      }
    } else {
      onlyIf("is current Daemon JVM  allowed") { isJavaVersionAllowed(JavaVersion.current(), testTask.name) }
    }

    // temporary workaround when using Java16+: some tests require reflective access to java.lang/java.util
    configureJvmArgs(
    testTask,
    JavaVersion.VERSION_16,
    ['--add-opens=java.base/java.lang=ALL-UNNAMED', '--add-opens=java.base/java.util=ALL-UNNAMED'],
    project.providers.provider { project.properties['allowReflectiveAccessToJdk'] as Boolean }.orElse(true)
    )

    if (configurations.hasProperty("latestDepTestRuntimeClasspath")) {
      doFirst {
        def testArtifacts = configurations.testRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
        def latestTestArtifacts = configurations.latestDepTestRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
        assert testArtifacts != latestTestArtifacts: "latestDepTest dependencies are identical to test"
      }
    }
  }
}
configureTestJvm(project, applyCodeCoverage)


[JavaCompile, ScalaCompile, GroovyCompile].each { type ->
  tasks.withType(type).configureEach {
    if (options.fork) {
      options.forkOptions.with {
        memoryMaximumSize = "256M"
      }
    }
  }
}

if (project.plugins.hasPlugin('kotlin')) {
  ['compileKotlin', 'compileTestKotlin'].each { type ->
    tasks.named(type) {
      kotlinDaemonJvmArguments = ["-Xmx256m", "-XX:+UseParallelGC"]
    }
  }
}

tasks.withType(JavaExec).configureEach {
  if (!it.maxHeapSize) {
    it.maxHeapSize = '256M'
  }
}

// For reproducible builds
tasks.withType(AbstractArchiveTask).configureEach {
  preserveFileTimestamps = false
  reproducibleFileOrder = true
}

project.pluginManager.withPlugin('com.gradleup.shadow') {
  // Remove the no-deps jar from the archives to prevent publication
  // Also removes other distribution types (zip, tar etc.), only affects project in dd-smoke-tests
  configurations {
    named("archives") {
      outgoing.artifacts.clear()
      outgoing.artifact(project.tasks.named("shadowJar"))
    }
  }
}

if (project.hasProperty("removeJarVersionNumbers") && project.findProperty("removeJarVersionNumbers").asBoolean()) {
  tasks.withType(AbstractArchiveTask).configureEach {
    archiveVersion.unsetConvention()
    archiveVersion.set(null)
  }
}

// Configure the compile task with release if possible
// other wise use the java 8 compiler
tasks.withType(JavaCompile).configureEach {
  def targetVersion = JavaVersion.toVersion(targetCompatibility).majorVersion as Integer
  if (JavaVersion.current().isJava9Compatible()) {
    it.options.release = targetVersion
    // Disable '-options' because we are compiling for java8 from the daemon JDK deliberately
    it.options.compilerArgs.add('-Xlint:-options')
  } else {
    it.javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(targetVersion)
    }
  }
  doFirst("audit-compiler-setting") {
    def releaseFlagValue = options.release.getOrNull()
    if (releaseFlagValue != null && !JavaVersion.toVersion(targetCompatibility).isCompatibleWith(JavaVersion.toVersion(releaseFlagValue))) {
      logger.warn('⚠️ The release flag and targetCompatibility have different values **release will win**, targetCompatibility: ' + targetCompatibility.toString() + ', release: ' + releaseFlagValue + '\n' +
      '  compiler: ' + javaCompiler.get().executablePath.asFile)
    }
  }
}

/**
 * Customize the compiler config.
 * Adapts depending on the compile task type (java, groovy, scala covered).
 * For java changes the compiler from the toolchain, and adapts its configuration.
 *
 * For Groovy and Scala compile tasks only sets the launcher.
 */
ext.configureCompiler = (AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) -> {
  Provider<JavaCompiler> compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  Provider<JavaLauncher> launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  try {
    if (it instanceof JavaCompile) {
      JavaCompile jc = (JavaCompile) it
      jc.javaCompiler = compiler
      if (compatibilityVersion != null) {
        jc.targetCompatibility = compatibilityVersion
        jc.sourceCompatibility = compatibilityVersion
      }
      def isReleaseFlagIncompatibleWithTarget = compatibilityVersion != null
      && !compatibilityVersion.isCompatibleWith(JavaVersion.toVersion(toolchainVersion))
      if (unsetReleaseFlagReason != null || isReleaseFlagIncompatibleWithTarget || toolchainVersion == 8) {
        logger.debug("Not using --release for {}", jc.path)
        // Don't set the release flag, as code need unpublished symbols,
        // those are not accessible when using `--release N`
        // e.g. with sun.misc.SharedSecrets, or jdk.jfr.internal.JVM
        jc.options.release = null
        if (unsetReleaseFlagReason != null) {
          logger.info("Not using '--release' because: {}", unsetReleaseFlagReason)
        }
      } else if (JavaVersion.toVersion(toolchainVersion).isJava9Compatible()) {
        jc.options.release = toolchainVersion
        jc.options.compilerArgs.add('-Xlint:-options')
      }
    } else if (it instanceof GroovyCompile) {
      GroovyCompile gc = (GroovyCompile) it
      gc.javaLauncher = launcher
      if (compatibilityVersion != null) {
        it.sourceCompatibility = compatibilityVersion
        it.targetCompatibility = compatibilityVersion
      }
      if (unsetReleaseFlagReason != null) {
        logger.info("Using specific toolchain because: {}", unsetReleaseFlagReason)
      }
    } else if (it instanceof ScalaCompile) {
      ScalaCompile sc = (ScalaCompile) it
      sc.javaLauncher = launcher
    } else {
      throw new GradleException("Unsupported compile type: ${it.getClass()}")
    }
  } catch (NoSuchElementException ignored) {
    throw new GradleException("Unable to find compiler for Java $toolchainVersion. Have you set JAVA_${toolchainVersion}_HOME?")
  }
} as Closure<Void>

ext.configureGroovyCompiler = (int toolchainVersion, String... taskNames) -> {
  taskNames.each { taskName ->
    tasks.named(taskName, GroovyCompile) {
      configureCompiler(it, toolchainVersion)
    }
  }
} as Closure<Void>

ext.getJavaLauncherFor = (javaVersionInteger) -> {
  def launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(javaVersionInteger)
  }
  if (!launcher.present) {
    throw new GradleException("Unable to find launcher for Java $javaVersionInteger. Have you set JAVA_${javaVersionInteger}_HOME?")
  }
  return launcher
} as Closure<Provider<JavaLauncher>>

def isJavaVersionAllowedForProperty(JavaVersion version, String propertyPrefix = "") {
  def minProp = propertyPrefix.isEmpty() ? 'minJavaVersionForTests' : "${propertyPrefix}MinJavaVersionForTests"
  def maxProp = propertyPrefix.isEmpty() ? 'maxJavaVersionForTests' : "${propertyPrefix}MaxJavaVersionForTests"
  def definedMin = project.hasProperty(minProp)
  def definedMax = project.hasProperty(maxProp)
  if (definedMin && project.findProperty(minProp).compareTo(version) > 0) {
    logger.info("isJavaVersionAllowedForProperty is false b/o minProp=${minProp} is defined and greater than version=${version}")
    return false
  }
  //default to the general min if defined and specific one is was not defined
  if (!propertyPrefix.isEmpty() && !definedMin && project.hasProperty('minJavaVersionForTests') && project.findProperty('minJavaVersionForTests').compareTo(version) > 0) {
    logger.info("isJavaVersionAllowedForProperty is false b/o minJavaVersionForTests=${project.findProperty('minJavaVersionForTests')} is defined and greater than version=${version}")
    return false
  }
  if (definedMax && project.findProperty(maxProp).compareTo(version) < 0) {
    logger.info("isJavaVersionAllowedForProperty is false b/o maxProp=${project.findProperty(maxProp)} is defined and lower than version=${version}")
    return false
  }
  if (!propertyPrefix.isEmpty() && !definedMax && project.hasProperty('maxJavaVersionForTests') && project.findProperty('maxJavaVersionForTests').compareTo(version) < 0) {
    logger.info("isJavaVersionAllowedForProperty is false b/o maxJavaVersionForTests=${project.findProperty('maxJavaVersionForTests')} is defined and lower than version=${version}")
    return false
  }
  return true
}

def isJavaVersionAllowed(JavaVersion version, String testTaskName) {
  return isJavaVersionAllowedForProperty(version, testTaskName)
}

def isJavaLanguageVersionAllowed(JavaLanguageVersion languageVersion, String testTaskName) {
  def version = JavaVersion.toVersion(languageVersion.asInt())
  return isJavaVersionAllowed(version, testTaskName)
}

def isJdkForced(String javaName) {
  return (project.hasProperty('forceJdk') && project.findProperty('forceJdk').any { it.equalsIgnoreCase(javaName) })
}

def isJdkExcluded(String javaName) {
  return (project.hasProperty('excludeJdk') && project.findProperty('excludeJdk').any { it.equalsIgnoreCase(javaName) })
}

def getJavaHomePath(String path) {
  def javaHome = new File(path).toPath().toRealPath()
  return javaHome.endsWith("jre") ? javaHome.parent : javaHome
}

tasks.register('testJar', Jar) {
  dependsOn(testClasses)
  from(sourceSets.test.output)
  archiveClassifier = 'test'
}
