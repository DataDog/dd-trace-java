import datadog.gradle.plugin.testJvmConstraints.TestJvmConstraintsExtension
import datadog.gradle.plugin.testJvmConstraints.ProvideJvmArgsOnJvmLauncherVersion
import groovy.transform.CompileStatic

apply plugin: 'datadog.configure-tests'
apply plugin: 'java-library'
apply plugin: 'datadog.test-jvm-contraints'

apply from: "$rootDir/gradle/codenarc.gradle"
apply from: "$rootDir/gradle/forbiddenapis.gradle"
apply from: "$rootDir/gradle/spotless.gradle"
apply from: "$rootDir/gradle/spotbugs.gradle"
apply from: "$rootDir/gradle/repositories.gradle"
apply from: "$rootDir/gradle/test-suites.gradle"

// Glue code for Groovy DSL.
// TODO this extension need to go away once we move to convention plugins
ext.configureCompiler = (AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) -> {
  configureCompiler(it, toolchainVersion, compatibilityVersion, unsetReleaseFlagReason)
} as Closure<Void>

@CompileStatic
interface TracerSourceSetConfig {
  /**
   * Additional sourceSet output is added as `compileOnly` rather than `implementation`.
   *
   * This is useful to avoid some classes to be added to add classes to the wrog jar prefix.
   */
  Property<Boolean> getCompileOnly()

  /**
   * Whether to apply or not the JavaVersion to tests sources, default to `true`.
   *
   * In some cases we would like to avoid setting java version to for tests.
   * For example we would like to be able to run profiling tests with `ZULU8`,
   * but we cannot run it with other JDK8 implementations at the moment
   */
  Property<Boolean> getApplyForTestSources()
}

@CompileStatic
class TracerJavaExtension {
  public static String NAME = "tracerJava"
  private ObjectFactory objects
  private Project project

  TracerJavaExtension(ObjectFactory objects, ProviderFactory providers, Project project) {
    this.project = project
    this.objects = objects
  }

  /**
   * Same as [addSourceSetFor] used for compatibility when used in kotlin scripts within `withGroovyBuilder`.
   *
   * Once moved to convention plugins this can go away.
   *
   * @param javaVersion The wanted java version for these source.
   * @param sourceSetOptions
   */
  def addSourceSetFor(JavaVersion javaVersion, Map<String, Boolean> sourceSetOptions) {
    addSourceSetFor(javaVersion) {
      it.compileOnly.set(sourceSetOptions.getOrDefault('compileOnly', false))
      it.applyForTestSources.set(sourceSetOptions.getOrDefault('applyForTestSources', true))
    }
  }

  /**
   * Adds the source set `src/main/javaXX`, configures its compilation and its test jvm constraints.
   *
   * @param javaVersion The wanted java version for these source.
   * @param sourceSetConfigurer Options for this source set.
   */
  def addSourceSetFor(JavaVersion javaVersion, Action<? super TracerSourceSetConfig> sourceSetConfigurer = null) {
    def sourceSetConfig = objects.newInstance(TracerSourceSetConfig)
    if (sourceSetConfigurer != null) {
      sourceSetConfigurer.execute(sourceSetConfig)
    }
    project.extensions.getByType(TestJvmConstraintsExtension).minJavaVersion.set(javaVersion)

    def version = javaVersion
    def name = "java${version.majorVersion}"
    def sourceSets = project.extensions.getByType(SourceSetContainer)

    def mainForJavaVersionSourceSet = sourceSets.create("${SourceSet.MAIN_SOURCE_SET_NAME}_$name") {
      (it as SourceSet).java.srcDirs = ["${project.projectDir}/src/${SourceSet.MAIN_SOURCE_SET_NAME}/$name"]
    }

    // TODO Make 'configureCompiler' a general utility method
    def configureCompilerCl = project.extensions.getByType(ExtraPropertiesExtension).get("configureCompiler") as Closure
    project.tasks.named(mainForJavaVersionSourceSet.compileJavaTaskName, JavaCompile) {
      configureCompilerCl.call(it, version.majorVersion.toInteger().intValue(), version)
    }

    if (sourceSetConfig.applyForTestSources.orElse(true)) {
      // configures all test tasks
      project.tasks.withType(JavaCompile).configureEach {
        if (it.name.toLowerCase().contains("test")) {
          configureCompilerCl.call(it, version.majorVersion.toInteger().intValue(), version)
        }
      }
    }

    // "socket-utils" is only set to compileOnly because the implementation dependency incorrectly adds Java17 classes to all jar prefixes.
    // This causes the AgentJarIndex to search for other non-Java17 classes in the wrong prefix location and fail to resolve class names.
    if (sourceSetConfig.compileOnly.orElse(false).get()) {
      project.dependencies.add("compileOnly", mainForJavaVersionSourceSet.output)
    } else {
      project.dependencies.add("compileOnly", project.files(mainForJavaVersionSourceSet.compileClasspath))
      project.dependencies.add("implementation", mainForJavaVersionSourceSet.output)
    }

    project.tasks.named("jar", Jar) {
      it.from(mainForJavaVersionSourceSet.output)
    }
  }
}
def tracerJavaExtension = extensions.create(TracerJavaExtension.NAME, TracerJavaExtension, objects, providers, project)



// Only run one testcontainers test at a time
ext.testcontainersLimit = gradle.sharedServices.registerIfAbsent("testcontainersLimit", BuildService) {
  maxParallelUsages = 1
}

// Task for tests that want to run forked in their own separate JVM
if (tasks.matching({ it.name == 'forkedTest' }).empty) {
  tasks.register('forkedTest', Test) {
    useJUnitPlatform()
  }
}

def applyCodeCoverage = !(
project.path.startsWith(":dd-smoke-tests") ||
project.path == ":dd-java-agent" ||
project.path == ":dd-java-agent:load-generator" ||
project.path.startsWith(":dd-java-agent:benchmark") ||
project.path.startsWith(":dd-java-agent:instrumentation") ||
project.path.startsWith(":dd-java-agent:appsec:weblog:"))

// https://stackoverflow.com/questions/42501869/gradle-skip-jacoco-during-test
// https://poetengineer.postach.io/post/how-to-conditionally-enable-disable-jacoco-in-gradle-build
if (applyCodeCoverage) {
  apply from: "$rootDir/gradle/jacoco.gradle"
}

java {
  // Our minimum target
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8

  // See https://docs.gradle.org/current/userguide/upgrading_version_5.html, Automatic target JVM version
  disableAutoTargetJvm()
  withJavadocJar()
  withSourcesJar()
}

tasks.named("jar", Jar) {
  /**
   Make Jar build fail on duplicate files
   By default Gradle Jar task can put multiple files with the same name
   into a Jar. This may lead to confusion. For example if auto-service
   annotation processing creates files with same name in `scala` and
   `java` directory this would result in Jar having two files with the
   same name in it. Which in turn would result in only one of those
   files being actually considered when that Jar is used leading to very
   confusing failures.
   Instead we should 'fail early' and avoid building such Jars.
   */
  duplicatesStrategy = DuplicatesStrategy.FAIL

  manifest {
    attributes(
    "Implementation-Title": project.name,
    "Implementation-Version": project.version,
    "Implementation-Vendor": "Datadog",
    "Implementation-URL": "https://github.com/datadog/dd-trace-java",
    )
  }
}

tasks.withType(Javadoc).configureEach {
  options.encoding = "utf-8"
  options.docEncoding = "utf-8"
  options.charSet = "utf-8"

  options.addStringOption('Xdoclint:none', '-quiet')

  doFirst {
    if (project.ext.has("apiLinks")) {
      options.links(*project.apiLinks)
    }
  }
}

tasks.named("javadoc", Javadoc) {
  source = sourceSets.main.java.srcDirs
  classpath = configurations.compileClasspath

  options {
    setMemberLevel(JavadocMemberLevel.PUBLIC)
    setAuthor(true)

    links = ["https://docs.oracle.com/javase/8/docs/api/"]
    source = 8
  }
}

ext.conditionalJvmArgs = (Test testTask, JavaVersion applyFromVersion, List<String> jvmArgsToApply, Provider<Boolean> additionalCondition = null) -> {
  testTask.jvmArgumentProviders.add(new ProvideJvmArgsOnJvmLauncherVersion(
  testTask,
  applyFromVersion,
  jvmArgsToApply,
  additionalCondition ?: testTask.project.providers.provider { true }
  ))
}

// TODO move to test-suites config ?
tasks.withType(Test).configureEach { Test testTask ->
  if (configurations.hasProperty("latestDepTestRuntimeClasspath")) {
    doFirst {
      def testArtifacts = configurations.testRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      def latestTestArtifacts = configurations.latestDepTestRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      assert testArtifacts != latestTestArtifacts: "latestDepTest dependencies are identical to test"
    }
  }
}


[JavaCompile, ScalaCompile, GroovyCompile].each { type ->
  tasks.withType(type).configureEach {
    if (options.fork) {
      options.forkOptions.with {
        memoryMaximumSize = "256M"
      }
    }
  }
}

if (project.plugins.hasPlugin('kotlin')) {
  ['compileKotlin', 'compileTestKotlin'].each { type ->
    tasks.named(type) {
      kotlinDaemonJvmArguments = ["-Xmx256m", "-XX:+UseParallelGC"]
    }
  }
}

tasks.withType(JavaExec).configureEach {
  if (!it.maxHeapSize) {
    it.maxHeapSize = '256M'
  }
}

// For reproducible builds
tasks.withType(AbstractArchiveTask).configureEach {
  preserveFileTimestamps = false
  reproducibleFileOrder = true
}

project.pluginManager.withPlugin('com.gradleup.shadow') {
  // Remove the no-deps jar from the archives to prevent publication
  // Also removes other distribution types (zip, tar etc.), only affects project in dd-smoke-tests
  configurations {
    named("archives") {
      outgoing.artifacts.clear()
      outgoing.artifact(project.tasks.named("shadowJar"))
    }
  }
}

if (project.hasProperty("removeJarVersionNumbers") && project.findProperty("removeJarVersionNumbers").asBoolean()) {
  tasks.withType(AbstractArchiveTask).configureEach {
    archiveVersion.unsetConvention()
    archiveVersion.set(null)
  }
}

// Configure the compile task with release if possible
// other wise use the java 8 compiler
tasks.withType(JavaCompile).configureEach {
  def targetVersion = JavaVersion.toVersion(targetCompatibility).majorVersion as Integer
  if (JavaVersion.current().isJava9Compatible()) {
    it.options.release = targetVersion
    // Disable '-options' because we are compiling for java8 from the daemon JDK deliberately
    it.options.compilerArgs.add('-Xlint:-options')
  } else {
    it.javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(targetVersion)
    }
  }
  doFirst("audit-compiler-setting") {
    def releaseFlagValue = options.release.getOrNull()
    if (releaseFlagValue != null && !JavaVersion.toVersion(targetCompatibility).isCompatibleWith(JavaVersion.toVersion(releaseFlagValue))) {
      logger.warn('⚠️ The release flag and targetCompatibility have different values **release will win**, targetCompatibility: ' + targetCompatibility.toString() + ', release: ' + releaseFlagValue + '\n' +
      '  compiler: ' + javaCompiler.get().executablePath.asFile)
    }
  }
}

/**
 * Customize the compiler config.
 * Adapts depending on the compile task type (java, groovy, scala covered).
 * For java changes the compiler from the toolchain, and adapts its configuration.
 *
 * For Groovy and Scala compile tasks only sets the launcher.
 *
 * NOTE: This function is exposed via a closure
 */
def configureCompiler(AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) {
  Provider<JavaCompiler> compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  Provider<JavaLauncher> launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  try {
    if (it instanceof JavaCompile) {
      JavaCompile jc = (JavaCompile) it
      jc.javaCompiler = compiler
      if (compatibilityVersion != null) {
        jc.targetCompatibility = compatibilityVersion
        jc.sourceCompatibility = compatibilityVersion
      }
      def isReleaseFlagIncompatibleWithTarget = compatibilityVersion != null
      && !compatibilityVersion.isCompatibleWith(JavaVersion.toVersion(toolchainVersion))
      if (unsetReleaseFlagReason != null || isReleaseFlagIncompatibleWithTarget || toolchainVersion == 8) {
        logger.debug("Not using --release for {}", jc.path)
        // Don't set the release flag, as code need unpublished symbols,
        // those are not accessible when using `--release N`
        // e.g. with sun.misc.SharedSecrets, or jdk.jfr.internal.JVM
        jc.options.release = null
        if (unsetReleaseFlagReason != null) {
          logger.info("Not using '--release' because: {}", unsetReleaseFlagReason)
        }
      } else if (JavaVersion.toVersion(toolchainVersion).isJava9Compatible()) {
        jc.options.release = toolchainVersion
        jc.options.compilerArgs.add('-Xlint:-options')
      }
    } else if (it instanceof GroovyCompile) {
      GroovyCompile gc = (GroovyCompile) it
      gc.javaLauncher = launcher
      if (compatibilityVersion != null) {
        it.sourceCompatibility = compatibilityVersion
        it.targetCompatibility = compatibilityVersion
      }
      if (unsetReleaseFlagReason != null) {
        logger.info("Using specific toolchain because: {}", unsetReleaseFlagReason)
      }
    } else if (it instanceof ScalaCompile) {
      ScalaCompile sc = (ScalaCompile) it
      sc.javaLauncher = launcher
    } else {
      throw new GradleException("Unsupported compile type: ${it.getClass()}")
    }
  } catch (NoSuchElementException ignored) {
    throw new GradleException("Unable to find compiler for Java $toolchainVersion. Have you set JAVA_${toolchainVersion}_HOME?")
  }
}

ext.getJavaLauncherFor = (javaVersionInteger) -> {
  def launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(javaVersionInteger)
  }
  if (!launcher.present) {
    throw new GradleException("Unable to find launcher for Java $javaVersionInteger. Have you set JAVA_${javaVersionInteger}_HOME?")
  }
  return launcher
} as Closure<Provider<JavaLauncher>>


tasks.register('testJar', Jar) {
  dependsOn(testClasses)
  from(sourceSets.test.output)
  archiveClassifier = 'test'
}
