import groovy.transform.CompileStatic
import datadog.gradle.plugin.testJvmConstraints.ProvideJvmArgsOnJvmLauncherVersion

apply plugin: 'java-library'
apply plugin: 'datadog.test-jvm-contraints'

apply from: "$rootDir/gradle/codenarc.gradle"
apply from: "$rootDir/gradle/forbiddenapis.gradle"
apply from: "$rootDir/gradle/spotless.gradle"
apply from: "$rootDir/gradle/spotbugs.gradle"
apply from: "$rootDir/gradle/repositories.gradle"
apply from: "$rootDir/gradle/test-suites.gradle"


@CompileStatic
class TracerJavaExtension {
  // TODO handle this style as well
  // ext {
  //   forkedTestMaxJavaVersionForTests = JavaVersion.VERSION_11
  //   mule46ForkedTestMaxJavaVersionForTests = JavaVersion.VERSION_11
  //   latestDepForkedTestMinJavaVersionForTests = JavaVersion.VERSION_17
  //   latestDepForkedTestMaxJavaVersionForTests = JavaVersion.VERSION_17
  // }

  Property<Boolean> skipSettingTestJavaVersion
  // Property<JavaVersion> minJavaVersionForTests
  // Property<JavaVersion> maxJavaVersionForTests
  // MapProperty<String, JavaVersion> minJavaVersionForTestTasks
  // ListProperty<String> forceJdk
  // ListProperty<String> excludeJdk

  TracerJavaExtension(ObjectFactory objects, ProviderFactory providers, Project project) {
    skipSettingTestJavaVersion = objects.property(Boolean)//.convention(providers.provider { project.findProperty('skipSettingTestJavaVersion') as Boolean })
  //   minJavaVersionForTests = objects.property(JavaVersion) //.convention(providers.provider { project.findProperty('minJavaVersionForTests') as JavaVersion })
  //   maxJavaVersionForTests = objects.property(JavaVersion)//.convention(providers.provider { project.findProperty('maxJavaVersionForTests') as JavaVersion })
  //   forceJdk = objects.listProperty(String).convention([]) //.convention(providers.provider { project.findProperty('forceJdk') as List<String> })
  //   excludeJdk = objects.listProperty(String).convention([]) //.convention(providers.provider { project.findProperty('excludeJdk') as List<String> })
  }

  def configureSourceSet(JavaVersion javaVersion) {
    // TODO configure source sets and co
  }
}
def tracerJavaExtension = extensions.create("tracerJava", TracerJavaExtension, objects, providers, project)



// Only run one testcontainers test at a time
ext.testcontainersLimit = gradle.sharedServices.registerIfAbsent("testcontainersLimit", BuildService) {
  maxParallelUsages = 1
}

// Task for tests that want to run forked in their own separate JVM
if (tasks.matching({ it.name == 'forkedTest' }).empty) {
  tasks.register('forkedTest', Test) {
    useJUnitPlatform()
  }
}

def applyCodeCoverage = !(
  project.path.startsWith(":dd-smoke-tests") ||
  project.path == ":dd-java-agent" ||
  project.path == ":dd-java-agent:load-generator" ||
  project.path.startsWith(":dd-java-agent:benchmark") ||
  project.path.startsWith(":dd-java-agent:instrumentation") ||
  project.path.startsWith(":dd-java-agent:appsec:weblog:"))

ext.applyCodeCoverage = applyCodeCoverage

if (applyCodeCoverage) {
  apply from: "$rootDir/gradle/jacoco.gradle"
}

java {
  // Our minimum target
  sourceCompatibility = JavaVersion.VERSION_1_8
  targetCompatibility = JavaVersion.VERSION_1_8

  // See https://docs.gradle.org/current/userguide/upgrading_version_5.html, Automatic target JVM version
  disableAutoTargetJvm()
  withJavadocJar()
  withSourcesJar()
}

// TODO source set config, below is pseudo code based on tracerJavaExtension.minJavaVersionForTests
// sourceSets {
//   def wanted_version = tracerJavaExtension.minJavaVersionForTests.orNull
//   if (wanted_version) {
//     println("source set config ${project.path}")
//     register("${SourceSet.MAIN_SOURCE_SET_NAME}2_java${wanted_version.majorVersion}") {
//       java.srcDirs = ["${project.projectDir}/src/main/yaj${wanted_version.majorVersion}"]
//     }
//   }
// }

// TODO configures the source sets via the extension
if (project.hasProperty('minJavaVersionForTests') && project.findProperty('minJavaVersionForTests') != JavaVersion.VERSION_1_7) {
  def version = JavaVersion.toVersion(project.findProperty('minJavaVersionForTests'))
  def name = "java${version.majorVersion}"
  def mainForJavaVersionSourceSet = sourceSets.create("main_$name") {
    java.srcDirs = ["${project.projectDir}/src/main/$name"]
  }

  // Task name is registered when source set was created
  tasks.named(mainForJavaVersionSourceSet.compileJavaTaskName, JavaCompile) {
    configureCompiler(it, version.majorVersion.toInteger().intValue(), version)
  }

  // "socket-utils" is only set to compileOnly because the implementation dependency incorrectly adds Java17 classes to all jar prefixes.
  // This causes the AgentJarIndex to search for other non-Java17 classes in the wrong prefix location and fail to resolve class names.
  dependencies {
    if ("${project.projectDir}".endsWith("socket-utils")) {
      compileOnly(files(project.sourceSets."main_$name".output))
    } else {
      compileOnly(files(project.sourceSets."main_$name".compileClasspath))
      implementation(files(project.sourceSets."main_$name".output))
    }
  }

  tasks.named("jar", Jar) {
    from sourceSets."main_$name".output
  }

  // TODO configure this via extension
  // In some cases we would like to avoid setting java version to `minJavaVersionForTests`.
  // For example we would like to be able to run profiling tests with ZULU8, but we cannot run it with other JDK8 implementations at the moment
  def skipSettingTestJavaVersion = project.hasProperty('skipSettingTestJavaVersion') && project.findProperty('skipSettingTestJavaVersion')
  if (!skipSettingTestJavaVersion) {
    tasks.withType(JavaCompile).configureEach {
      if (it.name.toLowerCase().contains("test")) {
        sourceCompatibility = version
        targetCompatibility = version
      }
    }
  }
}

tasks.named("jar", Jar) {
  /**
   Make Jar build fail on duplicate files
   By default Gradle Jar task can put multiple files with the same name
   into a Jar. This may lead to confusion. For example if auto-service
   annotation processing creates files with same name in `scala` and
   `java` directory this would result in Jar having two files with the
   same name in it. Which in turn would result in only one of those
   files being actually considered when that Jar is used leading to very
   confusing failures.
   Instead we should 'fail early' and avoid building such Jars.
   */
  duplicatesStrategy = DuplicatesStrategy.FAIL

  manifest {
    attributes(
      "Implementation-Title": project.name,
      "Implementation-Version": project.version,
      "Implementation-Vendor": "Datadog",
      "Implementation-URL": "https://github.com/datadog/dd-trace-java",
      )
  }
}

tasks.withType(Javadoc).configureEach {
  options.encoding = "utf-8"
  options.docEncoding = "utf-8"
  options.charSet = "utf-8"

  options.addStringOption('Xdoclint:none', '-quiet')

  doFirst {
    if (project.ext.has("apiLinks")) {
      options.links(*project.apiLinks)
    }
  }
}

tasks.named("javadoc", Javadoc) {
  source = sourceSets.main.java.srcDirs
  classpath = configurations.compileClasspath

  options {
    setMemberLevel(JavadocMemberLevel.PUBLIC)
    setAuthor(true)

    links = ["https://docs.oracle.com/javase/8/docs/api/"]
    source = 8
  }
}

ext.configureJvmArgs = (Test testTask, JavaVersion applyFromVersion, List<String> jvmArgsToApply, Provider<Boolean> additionalCondition = null) -> {
  testTask.jvmArgumentProviders.add(new ProvideJvmArgsOnJvmLauncherVersion(
  testTask,
  applyFromVersion,
  jvmArgsToApply,
  additionalCondition ?: testTask.project.providers.provider { true }
  ))
}

// TODO move to test-suites config ?
tasks.withType(Test).configureEach { Test testTask ->
  if (configurations.hasProperty("latestDepTestRuntimeClasspath")) {
    doFirst {
      def testArtifacts = configurations.testRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      def latestTestArtifacts = configurations.latestDepTestRuntimeClasspath.resolvedConfiguration.resolvedArtifacts
      assert testArtifacts != latestTestArtifacts: "latestDepTest dependencies are identical to test"
    }
  }
}


[JavaCompile, ScalaCompile, GroovyCompile].each { type ->
  tasks.withType(type).configureEach {
    if (options.fork) {
      options.forkOptions.with {
        memoryMaximumSize = "256M"
      }
    }
  }
}

if (project.plugins.hasPlugin('kotlin')) {
  ['compileKotlin', 'compileTestKotlin'].each { type ->
    tasks.named(type) {
      kotlinDaemonJvmArguments = ["-Xmx256m", "-XX:+UseParallelGC"]
    }
  }
}

tasks.withType(JavaExec).configureEach {
  if (!it.maxHeapSize) {
    it.maxHeapSize = '256M'
  }
}

// For reproducible builds
tasks.withType(AbstractArchiveTask).configureEach {
  preserveFileTimestamps = false
  reproducibleFileOrder = true
}

project.pluginManager.withPlugin('com.gradleup.shadow') {
  // Remove the no-deps jar from the archives to prevent publication
  // Also removes other distribution types (zip, tar etc.), only affects project in dd-smoke-tests
  configurations {
    named("archives") {
      outgoing.artifacts.clear()
      outgoing.artifact(project.tasks.named("shadowJar"))
    }
  }
}

if (project.hasProperty("removeJarVersionNumbers") && project.findProperty("removeJarVersionNumbers").asBoolean()) {
  tasks.withType(AbstractArchiveTask).configureEach {
    archiveVersion.unsetConvention()
    archiveVersion.set(null)
  }
}

// Configure the compile task with release if possible
// other wise use the java 8 compiler
tasks.withType(JavaCompile).configureEach {
  def targetVersion = JavaVersion.toVersion(targetCompatibility).majorVersion as Integer
  if (JavaVersion.current().isJava9Compatible()) {
    it.options.release = targetVersion
    // Disable '-options' because we are compiling for java8 from the daemon JDK deliberately
    it.options.compilerArgs.add('-Xlint:-options')
  } else {
    it.javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(targetVersion)
    }
  }
  doFirst("audit-compiler-setting") {
    def releaseFlagValue = options.release.getOrNull()
    if (releaseFlagValue != null && !JavaVersion.toVersion(targetCompatibility).isCompatibleWith(JavaVersion.toVersion(releaseFlagValue))) {
      logger.warn('⚠️ The release flag and targetCompatibility have different values **release will win**, targetCompatibility: ' + targetCompatibility.toString() + ', release: ' + releaseFlagValue + '\n' +
      '  compiler: ' + javaCompiler.get().executablePath.asFile)
    }
  }
}

/**
 * Customize the compiler config.
 * Adapts depending on the compile task type (java, groovy, scala covered).
 * For java changes the compiler from the toolchain, and adapts its configuration.
 *
 * For Groovy and Scala compile tasks only sets the launcher.
 */
ext.configureCompiler = (AbstractCompile it, int toolchainVersion, JavaVersion compatibilityVersion = null, String unsetReleaseFlagReason = null) -> {
  Provider<JavaCompiler> compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  Provider<JavaLauncher> launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(toolchainVersion)
  }
  try {
    if (it instanceof JavaCompile) {
      JavaCompile jc = (JavaCompile) it
      jc.javaCompiler = compiler
      if (compatibilityVersion != null) {
        jc.targetCompatibility = compatibilityVersion
        jc.sourceCompatibility = compatibilityVersion
      }
      def isReleaseFlagIncompatibleWithTarget = compatibilityVersion != null
      && !compatibilityVersion.isCompatibleWith(JavaVersion.toVersion(toolchainVersion))
      if (unsetReleaseFlagReason != null || isReleaseFlagIncompatibleWithTarget || toolchainVersion == 8) {
        logger.debug("Not using --release for {}", jc.path)
        // Don't set the release flag, as code need unpublished symbols,
        // those are not accessible when using `--release N`
        // e.g. with sun.misc.SharedSecrets, or jdk.jfr.internal.JVM
        jc.options.release = null
        if (unsetReleaseFlagReason != null) {
          logger.info("Not using '--release' because: {}", unsetReleaseFlagReason)
        }
      } else if (JavaVersion.toVersion(toolchainVersion).isJava9Compatible()) {
        jc.options.release = toolchainVersion
        jc.options.compilerArgs.add('-Xlint:-options')
      }
    } else if (it instanceof GroovyCompile) {
      GroovyCompile gc = (GroovyCompile) it
      gc.javaLauncher = launcher
      if (compatibilityVersion != null) {
        it.sourceCompatibility = compatibilityVersion
        it.targetCompatibility = compatibilityVersion
      }
      if (unsetReleaseFlagReason != null) {
        logger.info("Using specific toolchain because: {}", unsetReleaseFlagReason)
      }
    } else if (it instanceof ScalaCompile) {
      ScalaCompile sc = (ScalaCompile) it
      sc.javaLauncher = launcher
    } else {
      throw new GradleException("Unsupported compile type: ${it.getClass()}")
    }
  } catch (NoSuchElementException ignored) {
    throw new GradleException("Unable to find compiler for Java $toolchainVersion. Have you set JAVA_${toolchainVersion}_HOME?")
  }
} as Closure<Void>

ext.configureGroovyCompiler = (int toolchainVersion, String... taskNames) -> {
  taskNames.each { taskName ->
    tasks.named(taskName, GroovyCompile) {
      configureCompiler(it, toolchainVersion)
    }
  }
} as Closure<Void>

ext.getJavaLauncherFor = (javaVersionInteger) -> {
  def launcher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(javaVersionInteger)
  }
  if (!launcher.present) {
    throw new GradleException("Unable to find launcher for Java $javaVersionInteger. Have you set JAVA_${javaVersionInteger}_HOME?")
  }
  return launcher
} as Closure<Provider<JavaLauncher>>


tasks.register('testJar', Jar) {
  dependsOn(testClasses)
  from(sourceSets.test.output)
  archiveClassifier = 'test'
}

apply from: "$rootDir/gradle/configure_tests.gradle"
