import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

// Schedule thread and heap dumps collection near test timeout.
tasks.withType(Test).configureEach { testTask ->
  String taskName = testTask.path.replaceAll(/[^A-Za-z0-9_]/, "_")
  long startedAt = System.currentTimeMillis()

  doFirst {
    if (!testTask.timeout.present) {
      logger.info("No timeout for ${taskName}; skipping dump scheduler")
      return
    }

    def scheduler = Executors.newSingleThreadScheduledExecutor({ r ->
      Thread t = new Thread(r, "dump_scheduler_${taskName}")
      t.daemon = true
      t
    })

    // Calculate delay for taking dumps as test timeout minus 1 minutes, but no less than 1 minute.
    def delayMinutes = Math.max(1L, testTask.timeout.get().minusMinutes(1).toMinutes())

    def future = scheduler.schedule({
      logger.warn("Taking dumps for: ${taskName} after ${delayMinutes} minutes.")

      try {
        // Use Gradle's build dir and adjust for CI artifacts collection if needed.
        def dumpsDir = layout.buildDirectory.dir('dumps').map {
          if (providers.environmentVariable("CI").isPresent()) {
            // Move reports into the folder collected by the collect_reports.sh script.
            new File(it.getAsFile().absolutePath.replace('dd-trace-java/dd-java-agent', 'dd-trace-java/workspace/dd-java-agent'))
          } else {
            it.asFile
          }
        }.get()

        dumpsDir.mkdirs()

        // For simplicity, use `0` as the PID, which collects all thread dumps across JVMs.
        // Single file can be useful for quick search.
        def threadDumpsFile = new File(dumpsDir, "all-thread-dumps-${System.currentTimeMillis()}.log")
        new ProcessBuilder("jcmd", "0", "Thread.print", "-l")
          .redirectErrorStream(true)
          .redirectOutput(threadDumpsFile)
          .start().waitFor()

        // Collect PIDs of all Java processes.
        def jvmProcesses = 'jcmd -l'.execute().text.readLines()

        // Collect pids for 'Gradle test executors'.
        def pids = jvmProcesses
          .findAll({ it.contains('Gradle Test Executor') })
          .collect({ it.substring(0, it.indexOf(' ')) })

        pids.each { pid ->
          // Collect heap dump by pid.
          def heapDumpFile = new File(dumpsDir, "${pid}-heap-dump-${System.currentTimeMillis()}.hprof").absolutePath
          def cmd = "jcmd ${pid} GC.heap_dump ${heapDumpFile}"
          cmd.execute().waitFor()

          // Collect thread dump by pid.
          def threadDumpFile = new File(dumpsDir, "${pid}-thread-dump-${System.currentTimeMillis()}.log")
          new ProcessBuilder('jcmd', pid, 'Thread.print', '-l')
            .redirectErrorStream(true)
            .redirectOutput(threadDumpFile)
            .start()
            .waitFor()
        }
      } catch (Throwable e) {
        logger.warn("Dumping failed: ${e.message}")
      }
      finally {
        scheduler.shutdown()
      }
    }, delayMinutes, TimeUnit.MINUTES)

    // Store handles for cancellation in doLast.
    logger.warn("Saving objects for: ${taskName}")
    testTask.extensions.extraProperties.set("dumpFuture_${taskName}", future)
    testTask.extensions.extraProperties.set("dumpScheduler_${taskName}", scheduler)
  }

  doLast {
    // Cancel if the task finished before the scheduled dump.
    def ex = testTask.extensions.extraProperties

    logger.warn("Dump cleanup logic after: ${(System.currentTimeMillis() - startedAt) / 1000} seconds")

    try {
      if (ex.hasProperty("dumpFuture_${taskName}")) {
        ex.get("dumpFuture_${taskName}")?.cancel(false)
      } else {
        logger.warn("dump future not found: ${taskName}")
      }
    } finally {
      if (ex.hasProperty("dumpScheduler_${taskName}")) {
        ex.get("dumpScheduler_${taskName}")?.shutdownNow()
      } else {
        logger.warn("dump scheduler not found: ${taskName}")
      }
    }
  }
}
