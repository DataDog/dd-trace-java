import java.time.Duration
import java.time.temporal.ChronoUnit
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

def isTestingInstrumentation(Project project) {
  return [
    "junit-4.10",
    "cucumber-junit-4",
    "junit-4.13",
    "munit-junit-4",
    "junit-5.3",
    "junit-5.8",
    "cucumber-junit-5",
    "spock-junit-5",
    "testng-6",
    "testng-7",
    "karate",
    "scalatest",
    "weaver"
  ].contains(project.name)
}

def forkedTestLimit = gradle.sharedServices.registerIfAbsent("forkedTestLimit", BuildService) {
  maxParallelUsages = 3
}

// Force timeout after 9 minutes (The timeout is configurable per job, default job timeout is 1h)
def testTimeoutDuration = Duration.of(9, ChronoUnit.MINUTES)

testing {
  suites.configureEach {
    // Use JUnit 5 to run tests
    useJUnitJupiter()
  }
}

// Go through the Test tasks and configure them
tasks.withType(Test).configureEach {
  // All tests must complete within 15 minutes.
  // This value is quite big because with lower values (3 mins) we were experiencing large number of false positives
  timeout = Duration.ofMinutes(15)

  // Disable all tests if skipTests property was specified
  onlyIf { !project.rootProject.hasProperty("skipTests") }

  // Enable force rerun of tests with -Prerun.tests.${project.name}
  outputs.upToDateWhen {
    !project.rootProject.hasProperty("rerun.tests.${project.name}")
  }

  // Avoid executing classes used to test testing frameworks instrumentation
  if (isTestingInstrumentation(project)) {
    exclude "**/TestSucceed*"
    exclude "**/TestFailed*"
    exclude "**/TestFailedWithSuccessPercentage*"
    exclude "**/TestError*"
    exclude "**/TestSkipped*"
    exclude "**/TestSkippedClass*"
    exclude "**/TestInheritance*", "**/BaseTestInheritance*"
    exclude "**/TestFactory*"
    exclude "**/TestParameterized*"
    exclude "**/TestRepeated*"
    exclude "**/TestTemplate*"
    exclude "**/TestDisableTestTrace*"
    exclude "**/TestAssumption*"
    exclude "**/TestParameterized*"
  }

  // Split up tests that want to run forked in their own separate JVM for generated tasks
  if (name.startsWith("forkedTest") || name.endsWith("ForkedTest")) {
    setExcludes([])
    setIncludes(["**/*ForkedTest*"])
    forkEvery 1
    // Limit the number of concurrent forked tests
    usesService(forkedTestLimit)
    onlyIf { !project.rootProject.hasProperty("skipForkedTests") }
  } else {
    exclude("**/*ForkedTest*")
  }

  timeout = testTimeoutDuration

  check.dependsOn it
}

Task allTestsTask = tasks.maybeCreate('allTests')
Task allLatestDepTestsTask = tasks.maybeCreate('allLatestDepTests')
project.afterEvaluate {
  tasks.withType(Test).each {
    if (it.name.containsIgnoreCase('latest')) {
      allLatestDepTestsTask.dependsOn it
    } else if (it.name != 'traceAgentTest') {
      allTestsTask.dependsOn it
    }
  }
}

// Setup flaky tests jobs. Done in afterEvaluate so that it applies to latestDepTest.
project.afterEvaluate {
  tasks.withType(Test).configureEach {
    // Flaky tests management for JUnit 5
    testFramework {
      if (it instanceof JUnitPlatformOptions) {
        if (project.rootProject.hasProperty("skipFlakyTests")) {
          excludeTags "flaky"
        } else if (project.rootProject.hasProperty("runFlakyTests")) {
          includeTags "flaky"
        }
      }
    }

    // Flaky tests management for Spock
    if (project.rootProject.hasProperty("skipFlakyTests")) {
      jvmArgs += ["-Drun.flaky.tests=false"]
    } else if (project.rootProject.hasProperty("runFlakyTests")) {
      jvmArgs += ["-Drun.flaky.tests=true"]
    }
  }
}

if (!project.property("activePartition")) {
  project.afterEvaluate {
    tasks.withType(Test).configureEach {
      enabled = false
    }
  }
}

tasks.withType(Test).configureEach {
  // https://docs.gradle.com/develocity/flaky-test-detection/
  // https://docs.gradle.com/develocity/gradle-plugin/current/#test_retry
  develocity.testRetry {
    if (System.getenv().containsKey("CI")) {
      maxRetries = 3
    }
  }
}

tasks.withType(Test).configureEach {
  doFirst {
    // This manipulation is requred to move files into folder
    // that will be collected by `collect_reports.sh` script.
    String buildDir = layout.buildDirectory.asFile.get().absolutePath.replace("dd-trace-java/dd-java-agent",
      "dd-trace-java/workspace/dd-java-agent")

    def dupmsDir = new File(buildDir, "dumps")
    dupmsDir.mkdirs()

    // Scheduler to execute logic that will dump threads and heap
    def scheduler = Executors.newSingleThreadScheduledExecutor({ r ->
      Thread t = new Thread(r, "dump-scheduler")
      t.setDaemon(true)
      return t
    })

    // Schedule the dump job:
    def future = scheduler.schedule({
      try {
        def threadDumpFile = new File(dupmsDir, "${System.currentTimeMillis()}-thread-dump.log")

        new ProcessBuilder("jcmd", "0", "Thread.print", "-l")
          .redirectErrorStream(true)
          .redirectOutput(threadDumpFile)
          .start().waitFor()

        // Collect PIDs of all Java processes:
        def jvmProcesses = "jcmd -l".execute().text.readLines()
        jvmProcesses.each { p ->
          // Process only test executors.
          if (!p.contains("Gradle Test Executor")) {
            return
          }

          def pid = p.substring(0, p.indexOf(' '))
          def heapDumpFile = "${dupmsDir.absolutePath}/${System.currentTimeMillis()}-${pid}.hprof"
          def cmd = "jcmd ${pid} GC.heap_dump ${heapDumpFile}"
          cmd.execute().waitFor()
        }
      } catch (Throwable t) {
        logger.warn("Dumping failed: ${t.message}", t)
      } finally {
        scheduler.shutdown()
      }
    }, 65, TimeUnit.SECONDS) // You can adjust this line with required delay.

    // Store handles for cancellation in doLast:
    ext.dumpFuture = future
    ext.dumpScheduler = scheduler
  }

  doLast {
    // Cancel if task completed faster than specified timeout.
    try {
      ext.dumpFuture?.cancel(false)
    } finally {
      ext.dumpScheduler?.shutdownNow()
    }
  }
}
